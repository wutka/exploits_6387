package main

import (
	"encoding/json"
	"fmt"
	"github.com/wutka/exploits_6387/server"
	"io/ioutil"
	"mime"
	"net/http"
	"strings"

	"github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 128000,
}

var config server.Config

func main() {

	configBytes, err := ioutil.ReadFile("config.json")
	if err != nil {
		fmt.Printf("Error reading configuration: %+v\n", err)
		return
	}

	err = json.Unmarshal(configBytes, &config)
	if err != nil {
		fmt.Printf("Error decoding config json: %+v\n", err)
		return
	}

	http.HandleFunc("/", handleMain)
	http.HandleFunc("/web/", handleWeb)

	http.HandleFunc("/ws", handleWebSocket)

	addr := fmt.Sprintf("localhost:%d", config.Port)
	fmt.Printf("Listening on %s\n", addr)
	http.ListenAndServe(addr, nil)
	/*
		sess, err := server.NewSession("target1")
		if err != nil {
			fmt.Printf("Error creating session: %+v", err)
			return
		}

		sess.Debug()
		memmap, err := sess.GetMemoryMap()
		fmt.Printf("%v\n", memmap)
		regs, err := sess.GetRegisters()
		fmt.Printf("%v\n", regs)
		dis, _ := sess.Disassemble()
		for _, d := range dis {
			fmt.Printf("%016x %s\n", d.Address, d.Instruction)
		}

		_, _ = sess.GetMemory(memmap.ExecEnd, memmap.DataEnd)

		sess.End()
	*/
}

func handleMain(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Location", "/web/index.html")
	w.WriteHeader(http.StatusTemporaryRedirect)
}

func handleWeb(w http.ResponseWriter, r *http.Request) {
	url := r.URL.Path
	if !strings.HasPrefix(url, "/web/") || len(url) < 6 {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte("Unknown url"))
	}

	contents, err := ioutil.ReadFile(".." + url)
	if err != nil {
		fmt.Printf("Error retrieving %s: %+v\n", url, err)
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte("Unknown url"))
		return
	}

	extension := strings.LastIndex(url, ".")
	if extension >= 0 {
		w.Header().Set("Content-type", mime.TypeByExtension(url[extension:]))
	}
	w.WriteHeader(http.StatusOK)
	w.Write(contents)
}

func handleWebSocket(w http.ResponseWriter, r *http.Request) {
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	server.HandleMessages(conn, config)
}
