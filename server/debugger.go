package server

import (
	"errors"
	"github.com/cyrus-and/gdb"
	"github.com/mitchellh/mapstructure"
	"io/ioutil"
	"regexp"
	"runtime"
	"strconv"
	"strings"
)

type Debugger struct {
	Filename string
	Session  *gdb.Gdb
	Pid      int
}

type ErrorPayload struct {
	Msg string
}

type RegisterNamePayload struct {
	RegisterNames []string `mapstructure:"register-names"`
}

type RegisterValue struct {
	Number string
	Value  string
}

type RegisterValuePayload struct {
	RegisterValues []RegisterValue `mapstructure:"register-values"`
}

type MemoryMap struct {
	ExecStart  uint64
	ExecEnd    uint64
	DataStart  uint64
	DataEnd    uint64
	StackStart uint64
	StackEnd   uint64
}

type ThreadGroup struct {
	Cores      string
	Executable string
	Id         string
	Pid        string
	Type       string
}

type ThreadGroups struct {
	Groups []ThreadGroup
}

func NewSession(filename string) (*Debugger, error) {
	gdb, err := gdb.New(nil)
	if err != nil {
		return nil, err
	}

	session := Debugger{
		Filename: filename,
		Session:  gdb,
	}

	return &session, nil
}

var memmapRegex = regexp.MustCompile("^([0-9a-f]*)-([0-9a-f]*) *([^ ]*) *([^ ]*) *([^ ]*) *([^ ]*) *(.*)$")

func (s *Debugger) GetMemoryMap() (MemoryMap, error) {
	memoryMap := MemoryMap{}

	mmapData, err := ioutil.ReadFile("/proc/" + strconv.Itoa(s.Pid) + "/maps")
	if err != nil {
		return memoryMap, err
	}

	mmapLines := strings.Split(string(mmapData), "\n")
	foundExec := false
	var dataStart uint64 = 0
	var dataEnd uint64 = 0
	for _, line := range mmapLines {
		match := memmapRegex.FindStringSubmatch(line)
		if match == nil {
			continue
		}
		start, _ := strconv.ParseUint(match[1], 16, 64)
		end, _ := strconv.ParseUint(match[2], 16, 64)
		perms := match[3]
		name := match[7]

		if strings.HasSuffix(name, s.Filename) {
			if !foundExec && strings.Contains(perms, "x") {
				foundExec = true
				memoryMap.ExecStart = start
				memoryMap.ExecEnd = end
			} else if foundExec {
				if dataStart == 0 {
					dataStart = start
				}
				dataEnd = end
			}
		} else if name == "[stack]" {
			memoryMap.StackStart = start
			memoryMap.StackEnd = end
		}
	}
	memoryMap.DataStart = dataStart
	memoryMap.DataEnd = dataEnd

	return memoryMap, nil
}

func (s *Debugger) Send(command string, payload interface{}) error {
	resp, err := s.Session.Send(command)
	if err != nil {
		return err
	}
	if resp["class"].(string) == "error" {
		errPayload := ErrorPayload{}
		mapstructure.Decode(resp["payload"], &errPayload)
		return errors.New(errPayload.Msg)
	}

	mapstructure.Decode(resp["payload"], payload)

	return nil
}

func (s *Debugger) SendNoResp(command string) error {
	resp, err := s.Session.Send(command)
	if err != nil {
		return err
	}
	if resp["class"].(string) == "error" {
		errPayload := ErrorPayload{}
		mapstructure.Decode(resp["payload"], &errPayload)
		return errors.New(errPayload.Msg)
	}

	return nil
}

func (s *Debugger) Debug() error {
	err := s.SendNoResp("file-exec-and-symbols ../target_programs/" + s.Filename)
	if err != nil {
		return err
	}

	err = s.SendNoResp("break-insert _start")
	if err != nil {
		return err
	}

	err = s.SendNoResp("exec-run")
	if err != nil {
		return err
	}

	groups := ThreadGroups{}

	err = s.Send("list-thread-groups", &groups)
	if err != nil {
		return nil
	}

	for _, tg := range groups.Groups {
		if tg.Type == "process" {
			s.Pid, _ = strconv.Atoi(tg.Pid)
		}
	}

	return nil
}

func (s *Debugger) Step() error {
	_, err := s.Session.Send("exec-next-instruction")
	return err
}
func (s *Debugger) GetMemory(start uint64, length int) ([]byte, error) {
	return nil, nil
}

func makeRegMap(regs []string) map[string]string {
	result := map[string]string{}
	for _, s := range regs {
		result[s] = s
	}
	return result
}

var registerLists = map[string]map[string]string{
	"amd64": makeRegMap([]string{"rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "rsp",
		"r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15", "rip",
		"eflags", "cs", "ss", "ds", "es", "fs", "gs"}),
}

func (s *Debugger) GetRegisters() (map[string]uint64, error) {
	regNamePayload := RegisterNamePayload{}
	err := s.Send("data-list-register-names", &regNamePayload)
	if err != nil {
		return nil, err
	}

	regNumbers := []string{}
	for i, rn := range regNamePayload.RegisterNames {
		if len(rn) > 0 {
			_, ok := registerLists[runtime.GOARCH][rn]
			if ok {
				regNumbers = append(regNumbers, strconv.Itoa(i))
			}
		}
	}

	regValuePayload := RegisterValuePayload{}
	err = s.Send("data-list-register-values x "+strings.Join(regNumbers, " "), &regValuePayload)

	if err != nil {
		return nil, err
	}

	result := map[string]uint64{}
	for _, regVal := range regValuePayload.RegisterValues {
		i, _ := strconv.Atoi(regVal.Number)
		v, _ := strconv.ParseUint(regVal.Value[2:], 16, 64)
		result[regNamePayload.RegisterNames[i]] = v
	}

	return result, err
}

//func (s *Debugger) toggleBreakpoint(uint64 addr) error {
//}

func (s *Debugger) End() error {
	return s.Session.Exit()
}
