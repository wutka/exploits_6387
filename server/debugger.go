package server

import (
	"errors"
	"fmt"
	"github.com/mitchellh/mapstructure"
	"github.com/wutka/gdb"
	"io/ioutil"
	"path"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

type Debugger struct {
	Filename    string
	Session     *gdb.Gdb
	Pid         int
	MemoryMap   MemoryMap
	RegisterMap map[string]string
}

type ErrorPayload struct {
	Msg string
}

type RegisterNamePayload struct {
	RegisterNames []string `mapstructure:"register-names"`
}

type RegisterValue struct {
	Number string
	Value  string
}

type RegisterValuePayload struct {
	RegisterValues []RegisterValue `mapstructure:"register-values"`
}

type AvailableMemoryRange struct {
	Start uint64
	End   uint64
}
type MemoryMap struct {
	ExecStart  uint64
	ExecEnd    uint64
	DataStart  uint64
	DataEnd    uint64
	StackStart uint64
	StackEnd   uint64
	Ranges     []AvailableMemoryRange
}

type ThreadGroup struct {
	Cores      string
	Executable string
	Id         string
	Pid        string
	Type       string
}

type ThreadGroups struct {
	Groups []ThreadGroup
}

type DisassemblyAsmLine struct {
	Address  string
	FuncName string `mapstructure:"func-name"`
	Inst     string
	Offset   string
}

type DisassemblySourceAndAsmLine struct {
	File         string `mapstructure:"file"`
	Fullname     string
	Line         string
	Instructions []DisassemblyAsmLine `mapstructure:"line_asm_insn"`
}

type DisassemblyAsmIns struct {
	Line DisassemblySourceAndAsmLine `mapstructure:"src_and_asm_line""`
}

type Disassembly struct {
	Instructions []DisassemblyAsmIns `mapstructure:"asm_insns"`
}

type DisassembledInstruction struct {
	Address     uint64
	Instruction string
}

type MemoryImageSegment struct {
	Address string   `mapstructure:"addr"`
	Data    []string `mapstructure:"data"`
}

type MemoryImage struct {
	Address string               `mapstructure:"addr"`
	Memory  []MemoryImageSegment `mapstructure:"memory"`
}

type Breakpoint struct {
	Number  string `mapstructure:"number"`
	Address string `mapstructure:"addr"`
}

type BreakpointTable struct {
	Body []Breakpoint `mapstructure:"body"`
}

type BreakpointTablePayload struct {
	BreakpointTable BreakpointTable
}

var x int

func NewSession(filename string, processorConfig ProcessorConfig, callback func()) (*Debugger, error) {
	gdb, err := gdb.New(func(notification map[string]interface{}) {
		notifyType := notification["type"].(string)
		if notifyType == "console" {
			callback()
		} else if notifyType == "exec" {
			notifyClass := notification["class"].(string)
			if notifyClass == "stopped" {
				callback()
			}
		}
	})
	if err != nil {
		return nil, err
	}

	registerMap := map[string]string{}
	for _, reg := range processorConfig.Registers {
		registerMap[reg] = reg
	}
	session := Debugger{
		Filename:    filename,
		Session:     gdb,
		RegisterMap: registerMap,
	}

	return &session, nil
}

var memmapRegex = regexp.MustCompile("^([0-9a-f]*)-([0-9a-f]*) *([^ ]*) *([^ ]*) *([^ ]*) *([^ ]*) *(.*)$")

func (s *Debugger) GetMemoryMap() (MemoryMap, error) {
	_, filename := path.Split(s.Filename)

	memoryMap := MemoryMap{}

	mmapData, err := ioutil.ReadFile("/proc/" + strconv.Itoa(s.Pid) + "/maps")
	if err != nil {
		return memoryMap, err
	}

	mmapLines := strings.Split(string(mmapData), "\n")
	foundExec := false
	var dataStart uint64 = 0
	var dataEnd uint64 = 0

	var rangeStart uint64 = 0
	var rangeEnd uint64 = 0

	ranges := []AvailableMemoryRange{}

	for _, line := range mmapLines {
		match := memmapRegex.FindStringSubmatch(line)
		if match == nil {
			continue
		}
		start, _ := strconv.ParseUint(match[1], 16, 64)
		end, _ := strconv.ParseUint(match[2], 16, 64)
		perms := match[3]
		name := match[7]

		if start != rangeEnd {
			if rangeStart > 0 && rangeEnd > 0 && rangeStart < rangeEnd {
				ranges = append(ranges, AvailableMemoryRange{Start: rangeStart, End: rangeEnd})
			}
			rangeStart = start
		}
		rangeEnd = end
		if strings.HasSuffix(name, filename) {
			if !foundExec && strings.Contains(perms, "x") {
				foundExec = true
				memoryMap.ExecStart = start
				memoryMap.ExecEnd = end
			} else if foundExec {
				if dataStart == 0 {
					dataStart = start
				}
				dataEnd = end
			}
		} else if name == "[stack]" {
			memoryMap.StackStart = start
			memoryMap.StackEnd = end
		}
	}
	if rangeStart > 0 && rangeEnd > 0 && rangeStart < rangeEnd {
		ranges = append(ranges, AvailableMemoryRange{Start: rangeStart, End: rangeEnd})
	}
	memoryMap.DataStart = dataStart
	memoryMap.DataEnd = dataEnd
	memoryMap.Ranges = ranges

	return memoryMap, nil
}

func (s *Debugger) Send(command string, payload interface{}) error {
	resp, err := s.Session.Send(command)
	if err != nil {
		return err
	}

	//	jsonStr, _ := json.Marshal(resp)
	//	fmt.Printf("%s\n", string(jsonStr))

	if resp["class"].(string) == "error" {
		errPayload := ErrorPayload{}
		mapstructure.Decode(resp["payload"], &errPayload)
		return errors.New(errPayload.Msg)
	}

	mapstructure.Decode(resp["payload"], payload)

	return nil
}

func (s *Debugger) SendNoResp(command string) error {
	resp, err := s.Session.Send(command)
	if err != nil {
		return err
	}
	if resp["class"].(string) == "error" {
		errPayload := ErrorPayload{}
		mapstructure.Decode(resp["payload"], &errPayload)
		return errors.New(errPayload.Msg)
	}

	return nil
}

func (s *Debugger) Debug() error {
	err := s.SendNoResp("file-exec-and-symbols ../target_programs/" + s.Filename)
	if err != nil {
		return err
	}

	err = s.SendNoResp("break-insert _start")
	if err != nil {
		return err
	}

	err = s.SendNoResp("exec-run")
	if err != nil {
		return err
	}

	groups := ThreadGroups{}

	err = s.Send("list-thread-groups", &groups)
	if err != nil {
		return nil
	}

	for _, tg := range groups.Groups {
		if tg.Type == "process" {
			s.Pid, _ = strconv.Atoi(tg.Pid)
		}
	}

	s.MemoryMap, err = s.GetMemoryMap()
	if err != nil {
		return err
	}

	return nil
}

func (s *Debugger) Step() error {
	_, err := s.Session.Send("exec-step-instruction")
	return err
}

func (s *Debugger) Next() error {
	_, err := s.Session.Send("exec-next-instruction")
	return err
}

func (s *Debugger) Continue() error {
	_, err := s.Session.Send("exec-continue")
	return err
}

func (s *Debugger) SetBreakpoint(addr uint64) error {
	return s.SendNoResp(fmt.Sprintf("break-insert *0x%x", addr))

}

func (s *Debugger) ClearBreakpoint(addr uint64) error {
	breakpointPayload := BreakpointTablePayload{}
	err := s.Send("break-list", &breakpointPayload)
	if err != nil {
		return err
	}

	for _, bp := range breakpointPayload.BreakpointTable.Body {
		bpAddr, _ := strconv.ParseUint(bp.Address[2:], 16, 64)

		if bpAddr == addr {
			return s.SendNoResp("break-delete " + bp.Number)
		}
	}
	return errors.New(fmt.Sprintf("unable to locate breakpoint %16x", addr))
}

func (s *Debugger) ClearBreakpoints() error {
	breakpointPayload := BreakpointTablePayload{}
	err := s.Send("break-list", &breakpointPayload)
	if err != nil {
		return err
	}

	for _, bp := range breakpointPayload.BreakpointTable.Body {
		s.SendNoResp("break-delete " + bp.Number)
	}
	return nil
}

func makeRegMap(regs []string) map[string]string {
	result := map[string]string{}
	for _, s := range regs {
		result[s] = s
	}
	return result
}

func (s *Debugger) GetRegisters() (map[string]uint64, error) {
	regNamePayload := RegisterNamePayload{}
	err := s.Send("data-list-register-names", &regNamePayload)
	if err != nil {
		return nil, err
	}

	regNumbers := []string{}
	for i, rn := range regNamePayload.RegisterNames {
		if len(rn) > 0 {
			_, ok := s.RegisterMap[rn]
			if ok {
				regNumbers = append(regNumbers, strconv.Itoa(i))
			}
		}
	}

	regValuePayload := RegisterValuePayload{}
	err = s.Send("data-list-register-values x "+strings.Join(regNumbers, " "), &regValuePayload)

	if err != nil {
		return nil, err
	}

	result := map[string]uint64{}
	for _, regVal := range regValuePayload.RegisterValues {
		i, _ := strconv.Atoi(regVal.Number)
		v, _ := strconv.ParseUint(regVal.Value[2:], 16, 64)
		result[regNamePayload.RegisterNames[i]] = v
	}

	return result, err
}

//func (s *Debugger) toggleBreakpoint(uint64 addr) error {
//}

func (s *Debugger) Disassemble() ([]DisassembledInstruction, error) {
	disassembly := Disassembly{}
	startAddress := s.MemoryMap.ExecStart

	disassembledInsts := []DisassembledInstruction{}

	startAddressChanged := true
	addressesDisassembled := map[string]string{}

	for startAddress < s.MemoryMap.ExecEnd && startAddressChanged {
		startAddressChanged = false

		err := s.Send(fmt.Sprintf("data-disassemble -s 0x%x -e 0x%x 1",
			startAddress, s.MemoryMap.ExecEnd), &disassembly)
		if err != nil {
			return nil, err
		}

		functionStart := map[string]uint64{}
		for _, line := range disassembly.Instructions {
			for _, inst := range line.Line.Instructions {
				_, ok := addressesDisassembled[inst.Address]
				if !ok {
					addressesDisassembled[inst.Address] = inst.Address
				} else {
					continue
				}
				addr, _ := strconv.ParseUint(inst.Address[2:], 16, 64)
				instStr := inst.Inst
				_, ok = functionStart[inst.FuncName]
				if !ok {
					functionStart[inst.FuncName] = addr
					instStr = instStr + "    # " + inst.FuncName
				}
				disassembledInsts = append(disassembledInsts,
					DisassembledInstruction{Address: addr,
						Instruction: instStr})
				if addr+1 > startAddress {
					startAddress = addr + 1
					startAddressChanged = true
				}
			}
		}
	}

	sort.SliceStable(disassembledInsts,
		func(i, j int) bool {
			return disassembledInsts[i].Address < disassembledInsts[j].Address
		})
	return disassembledInsts, nil
}

func (s *Debugger) GetMemory(start uint64, end uint64) ([]byte, error) {
	memoryImage := MemoryImage{}
	req := fmt.Sprintf("data-read-memory %d u 1 %d %d",
		start, (end-start)/64, 64)
	err := s.Send(req, &memoryImage)
	if err != nil {
		//		fmt.Printf("Error doing memory read: %s\n", req)
		//		fmt.Printf("%+v", err)
		return nil, err
	}
	mem := []byte{}
	for _, seg := range memoryImage.Memory {
		segBytes := make([]byte, len(seg.Data))
		for i := 0; i < len(seg.Data); i++ {
			b, _ := strconv.ParseUint(seg.Data[i], 10, 8)
			segBytes[i] = byte(b)
		}
		mem = append(mem, segBytes...)
	}

	return mem, nil
}

func (s *Debugger) End() error {
	return s.Session.Exit()
}
