package server

import (
	"errors"
	"fmt"
	"github.com/mitchellh/mapstructure"
	"github.com/wutka/gdb"
	"io/ioutil"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
)

type Debugger struct {
	Filename  string
	Session   *gdb.Gdb
	Pid       int
	MemoryMap MemoryMap
}

type ErrorPayload struct {
	Msg string
}

type RegisterNamePayload struct {
	RegisterNames []string `mapstructure:"register-names"`
}

type RegisterValue struct {
	Number string
	Value  string
}

type RegisterValuePayload struct {
	RegisterValues []RegisterValue `mapstructure:"register-values"`
}

type MemoryMap struct {
	ExecStart  uint64
	ExecEnd    uint64
	DataStart  uint64
	DataEnd    uint64
	StackStart uint64
	StackEnd   uint64
}

type ThreadGroup struct {
	Cores      string
	Executable string
	Id         string
	Pid        string
	Type       string
}

type ThreadGroups struct {
	Groups []ThreadGroup
}

type DisassemblyAsmLine struct {
	Address  string
	FuncName string `mapstructure:"func-name"`
	Inst     string
	Offset   string
}

type DisassemblySourceAndAsmLine struct {
	File         string `mapstructure:"file"`
	Fullname     string
	Line         string
	Instructions []DisassemblyAsmLine `mapstructure:"line_asm_insn"`
}

type DisassemblyAsmIns struct {
	Line DisassemblySourceAndAsmLine `mapstructure:"src_and_asm_line""`
}

type Disassembly struct {
	Instructions []DisassemblyAsmIns `mapstructure:"asm_insns"`
}

type DisassembledInstruction struct {
	Address     uint64
	Instruction string
}

type MemoryImageSegment struct {
	Address string `mapstructure:"addr"`
	Data    []byte
}

type MemoryImage struct {
	Address string               `mapstructure:"addr"`
	Memory  []MemoryImageSegment `mapstructure:"memory"`
}

func NewSession(filename string) (*Debugger, error) {
	gdb, err := gdb.New(nil)
	if err != nil {
		return nil, err
	}

	session := Debugger{
		Filename: filename,
		Session:  gdb,
	}

	return &session, nil
}

var memmapRegex = regexp.MustCompile("^([0-9a-f]*)-([0-9a-f]*) *([^ ]*) *([^ ]*) *([^ ]*) *([^ ]*) *(.*)$")

func (s *Debugger) GetMemoryMap() (MemoryMap, error) {
	memoryMap := MemoryMap{}

	mmapData, err := ioutil.ReadFile("/proc/" + strconv.Itoa(s.Pid) + "/maps")
	if err != nil {
		return memoryMap, err
	}

	mmapLines := strings.Split(string(mmapData), "\n")
	foundExec := false
	var dataStart uint64 = 0
	var dataEnd uint64 = 0
	for _, line := range mmapLines {
		match := memmapRegex.FindStringSubmatch(line)
		if match == nil {
			continue
		}
		start, _ := strconv.ParseUint(match[1], 16, 64)
		end, _ := strconv.ParseUint(match[2], 16, 64)
		perms := match[3]
		name := match[7]

		if strings.HasSuffix(name, s.Filename) {
			if !foundExec && strings.Contains(perms, "x") {
				foundExec = true
				memoryMap.ExecStart = start
				memoryMap.ExecEnd = end
			} else if foundExec {
				if dataStart == 0 {
					dataStart = start
				}
				dataEnd = end
			}
		} else if name == "[stack]" {
			memoryMap.StackStart = start
			memoryMap.StackEnd = end
		}
	}
	memoryMap.DataStart = dataStart
	memoryMap.DataEnd = dataEnd

	return memoryMap, nil
}

func (s *Debugger) Send(command string, payload interface{}) error {
	resp, err := s.Session.Send(command)
	if err != nil {
		return err
	}

	//	jsonStr, _ := json.Marshal(resp)
	//	fmt.Printf("%s\n", string(jsonStr))

	if resp["class"].(string) == "error" {
		errPayload := ErrorPayload{}
		mapstructure.Decode(resp["payload"], &errPayload)
		return errors.New(errPayload.Msg)
	}

	mapstructure.Decode(resp["payload"], payload)

	return nil
}

func (s *Debugger) SendNoResp(command string) error {
	resp, err := s.Session.Send(command)
	if err != nil {
		return err
	}
	if resp["class"].(string) == "error" {
		errPayload := ErrorPayload{}
		mapstructure.Decode(resp["payload"], &errPayload)
		return errors.New(errPayload.Msg)
	}

	return nil
}

func (s *Debugger) Debug() error {
	err := s.SendNoResp("file-exec-and-symbols ../target_programs/" + s.Filename)
	if err != nil {
		return err
	}

	err = s.SendNoResp("break-insert _start")
	if err != nil {
		return err
	}

	err = s.SendNoResp("exec-run")
	if err != nil {
		return err
	}

	groups := ThreadGroups{}

	err = s.Send("list-thread-groups", &groups)
	if err != nil {
		return nil
	}

	for _, tg := range groups.Groups {
		if tg.Type == "process" {
			s.Pid, _ = strconv.Atoi(tg.Pid)
		}
	}

	s.MemoryMap, err = s.GetMemoryMap()
	if err != nil {
		return err
	}

	return nil
}

func (s *Debugger) Step() error {
	_, err := s.Session.Send("exec-next-instruction")
	return err
}

func makeRegMap(regs []string) map[string]string {
	result := map[string]string{}
	for _, s := range regs {
		result[s] = s
	}
	return result
}

var registerLists = map[string]map[string]string{
	"amd64": makeRegMap([]string{"rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "rsp",
		"r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15", "rip",
		"eflags", "cs", "ss", "ds", "es", "fs", "gs"}),
}

func (s *Debugger) GetRegisters() (map[string]uint64, error) {
	regNamePayload := RegisterNamePayload{}
	err := s.Send("data-list-register-names", &regNamePayload)
	if err != nil {
		return nil, err
	}

	regNumbers := []string{}
	for i, rn := range regNamePayload.RegisterNames {
		if len(rn) > 0 {
			_, ok := registerLists[runtime.GOARCH][rn]
			if ok {
				regNumbers = append(regNumbers, strconv.Itoa(i))
			}
		}
	}

	regValuePayload := RegisterValuePayload{}
	err = s.Send("data-list-register-values x "+strings.Join(regNumbers, " "), &regValuePayload)

	if err != nil {
		return nil, err
	}

	result := map[string]uint64{}
	for _, regVal := range regValuePayload.RegisterValues {
		i, _ := strconv.Atoi(regVal.Number)
		v, _ := strconv.ParseUint(regVal.Value[2:], 16, 64)
		result[regNamePayload.RegisterNames[i]] = v
	}

	return result, err
}

//func (s *Debugger) toggleBreakpoint(uint64 addr) error {
//}

func (s *Debugger) Disassemble() ([]DisassembledInstruction, error) {
	disassembly := Disassembly{}
	startAddress := s.MemoryMap.ExecStart

	disassembledInsts := []DisassembledInstruction{}

	startAddressChanged := true
	addressesDisassembled := map[string]string{}

	for startAddress < s.MemoryMap.ExecEnd && startAddressChanged {
		startAddressChanged = false

		err := s.Send(fmt.Sprintf("data-disassemble -s 0x%x -e 0x%x 1",
			startAddress, s.MemoryMap.ExecEnd), &disassembly)
		if err != nil {
			return nil, err
		}

		functionStart := map[string]uint64{}
		for _, line := range disassembly.Instructions {
			for _, inst := range line.Line.Instructions {
				_, ok := addressesDisassembled[inst.Address]
				if !ok {
					addressesDisassembled[inst.Address] = inst.Address
				} else {
					continue
				}
				addr, _ := strconv.ParseUint(inst.Address[2:], 16, 64)
				instStr := inst.Inst
				_, ok = functionStart[inst.FuncName]
				if !ok {
					functionStart[inst.FuncName] = addr
					instStr = instStr + "    # " + inst.FuncName
				}
				disassembledInsts = append(disassembledInsts,
					DisassembledInstruction{Address: addr,
						Instruction: instStr})
				if addr+1 > startAddress {
					startAddress = addr + 1
					startAddressChanged = true
				}
			}
		}
	}

	sort.SliceStable(disassembledInsts,
		func(i, j int) bool {
			return disassembledInsts[i].Address < disassembledInsts[j].Address
		})
	return disassembledInsts, nil
}

func (s *Debugger) GetMemory(start uint64, end uint64) ([]byte, error) {
	memoryImage := MemoryImage{}
	err := s.Send(fmt.Sprintf("data-read-memory %d u 1 %d %d",
		start, (end-start)/64, 64), &memoryImage)
	if err != nil {
		return nil, err
	}
	mem := []byte{}
	for _, seg := range memoryImage.Memory {
		mem = append(mem, seg.Data...)
	}

	return mem, nil
}

func (s *Debugger) End() error {
	return s.Session.Exit()
}
