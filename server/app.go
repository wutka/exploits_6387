package server

import (
	"encoding/hex"
	"errors"
	"fmt"
	"github.com/gdamore/tcell/v2"
	"github.com/rivo/tview"
	"io"
	"os/exec"
	"strconv"
	"strings"
)

type TargetConfig struct {
	Title      string
	TargetName string
}

type Config struct {
	Targets []TargetConfig
}

type ProcessorConfig struct {
	Registers  []string
	PCRegister string
	SPRegister string
}

type ProcConfig struct {
	Processors map[string]ProcessorConfig
}

type MemoryBlock struct {
	Address uint64
	Data    []byte
}

const (
	StateIdle = iota
	StateDebugging
	StateRunning
)

type Session struct {
	debugger      *Debugger
	command       *exec.Cmd
	stdin         io.Writer
	stdout        io.Reader
	state         int
	currentTarget TargetConfig

	application *tview.Application
	ui          tview.Primitive
	promptUi    tview.Primitive

	disassemblyText *tview.TextView
	memoryText      *tview.TextView
	registersText   *tview.TextView
	commandsText    *tview.TextView
	commandInput    *tview.InputField

	promptText     *tview.TextView
	promptInput    *tview.InputField
	promptHexInput *tview.Checkbox

	messageLine *tview.TextView

	memoryPos           uint64
	breakpointAddresses map[uint64]uint64

	processorConfig ProcessorConfig

	prompt      string
	lastCommand string
}

func RunApplication(config Config, procConfig ProcessorConfig) {
	session := &Session{
		state:           StateIdle,
		processorConfig: procConfig,
	}

	session.ui = session.InitializeUI(config)
	session.promptUi = session.InitializePromptUI(config)

	session.application = tview.NewApplication()
	session.application.EnableMouse(true)
	session.application.SetRoot(session.ui, true)

	if err := session.application.Run(); err != nil {
		panic(err)
	}

}

func (s *Session) InitializeUI(config Config) tview.Primitive {
	grid := tview.NewGrid().
		SetRows(1, 0, 1).
		SetColumns(0)

	currCol := 0

	for i, target := range config.Targets {
		button := tview.NewButton(target.Title)
		pos := i
		titleLen := len(target.Title)
		button.SetSelectedFunc(func() {
			s.handleMenuButton(&config.Targets[pos])
		})
		grid.AddItem(button, 0, currCol, 1, titleLen+3, 0, 0, false)
		currCol = currCol + titleLen + 3
	}
	button := tview.NewButton("Exit")
	button.SetSelectedFunc(func() {
		s.application.Stop()
	})
	grid.AddItem(button, 0, currCol, 1, 4, 0, 0, false)

	s.disassemblyText = tview.NewTextView()
	s.disassemblyText.SetBorder(true)
	s.disassemblyText.SetTitle("Disassembly")
	s.disassemblyText.SetDynamicColors(true)

	s.memoryText = tview.NewTextView()
	s.memoryText.SetBorder(true)
	s.memoryText.SetTitle("Memory")
	s.memoryText.SetDynamicColors(true)
	s.memoryText.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey {
		return s.handleMemoryTextKeyEvent(event)
	})

	s.registersText = tview.NewTextView()
	s.registersText.SetBorder(true)
	s.registersText.SetTitle("Registers")

	s.commandsText = tview.NewTextView()

	commandsGrid := tview.NewGrid()
	commandsGrid.SetBorder(true)
	commandsGrid.SetTitle("Commands")
	commandsGrid.SetRows(17, 0)
	commandsGrid.SetColumns(0)
	commandsGrid.AddItem(s.commandsText, 0, 0, 16, 28, 0, 0, false)
	s.commandInput = tview.NewInputField()
	s.commandInput.SetDoneFunc(func(key tcell.Key) {
		if key == tcell.KeyEnter {
			s.handleCommand(s.commandInput.GetText())
		}
	})
	prompt := tview.NewTextView()
	prompt.SetText("Cmd:")
	commandsGrid.AddItem(prompt, 17, 0, 1, 4, 0, 0, false)
	commandsGrid.AddItem(s.commandInput, 17, 4, 1, 24, 0, 0, false)

	grid.AddItem(s.disassemblyText, 1, 0, 20, 50, 0, 0, false)
	grid.AddItem(s.memoryText, 21, 0, 16, 50, 0, 0, false)
	grid.AddItem(commandsGrid, 1, 50, 20, 30, 0, 0, false)
	grid.AddItem(s.registersText, 21, 50, 16, 30, 0, 0, false)

	s.messageLine = tview.NewTextView()
	grid.AddItem(s.messageLine, 38, 0, 1, 80, 0, 0, false)

	return grid
}

func (s *Session) InitializePromptUI(config Config) tview.Primitive {
	grid := tview.NewGrid().
		SetRows(15, 0).
		SetColumns(0)

	s.promptText = tview.NewTextView()
	s.promptText.SetBorder(true)
	grid.AddItem(s.promptText, 0, 20, 5, 40, 0, 0, false)

	s.promptInput = tview.NewInputField()
	s.promptInput.SetDoneFunc(func(key tcell.Key) {
		if key == tcell.KeyEnter {
			s.handlePromptInput(s.promptInput.GetText())
		}
	})
	grid.AddItem(s.promptInput, 5, 20, 3, 40, 0, 0, true)

	s.promptHexInput = tview.NewCheckbox()
	s.promptHexInput.SetLabel("Check here to enable hex input")
	grid.AddItem(s.promptHexInput, 8, 20, 1, 40, 0, 0, false)

	return grid
}

func (s *Session) doYesNoPopup(prompt string, okText string, cancelText string, handlerFunc func(*Session, bool)) {
	modal := tview.NewModal().
		SetText(prompt).
		AddButtons([]string{okText, cancelText}).
		SetDoneFunc(func(buttonIndex int, buttonLabel string) {
			s.application.SetRoot(s.ui, true)
			handlerFunc(s, buttonIndex == 0)
		})
	s.application.SetRoot(modal, true)
}

func (s *Session) doPopup(prompt string, okText string) {
	modal := tview.NewModal().
		SetText(prompt).
		AddButtons([]string{okText}).
		SetDoneFunc(func(buttonIndex int, buttonLabel string) {
			s.application.SetRoot(s.ui, true)
		})
	s.application.SetRoot(modal, true)
}

func (s *Session) handleMenuButton(target *TargetConfig) {
	if s.state != StateIdle {
		if target.Title != s.currentTarget.Title {
			verb := "debugging"
			if s.state == StateRunning {
				verb = "running"
			}

			prompt := fmt.Sprintf("Stop %s target %s and switch to target %s?",
				verb, s.currentTarget.Title,
				target.Title)

			s.doYesNoPopup(prompt, "Yes", "No", func(s *Session, switchOk bool) {
				if switchOk {
					s.changeDebugTarget(*target)
				}
			})
		}
	}
	s.changeDebugTarget(*target)
}

func (s *Session) changeDebugTarget(target TargetConfig) {
	if s.debugger != nil {
		_ = s.debugger.Session.Exit()
		s.debugger = nil
	}

	if s.command != nil {
		_ = s.command.Process.Kill()
		s.command = nil
	}

	s.breakpointAddresses = map[uint64]uint64{}
	s.currentTarget = target

	s.restartDebugger()
}

func (s *Session) restartDebugger() {
	debugger, err := NewSession(s.currentTarget.TargetName, s.processorConfig,
		func() {
			go s.application.QueueUpdate(func() {
				s.updateDebuggingViews()
			})
		})
	if err != nil {
		s.doPopup(fmt.Sprintf("Error debugging target %s: %+v", s.currentTarget.TargetName, err),
			"Ok")
		s.state = StateIdle
		return
	}

	s.debugger = debugger
	s.clearBreakpoints()
	s.state = StateDebugging
	err = s.debugger.Debug()
	if err != nil {
		s.doPopup(fmt.Sprintf("Error debugging target %s: %+v", s.currentTarget.TargetName, err),
			"Ok")
		s.state = StateIdle
		return
	}

	go s.targetReader()

	s.memoryPos = s.debugger.MemoryMap.Ranges[0].Start

	s.updateDebuggingViews()
}

func (s *Session) clearBreakpoints() {
	s.breakpointAddresses = map[uint64]uint64{}
}

func (s *Session) updateDebuggingViews() {
	if s.state != StateDebugging {
		return
	}
	registers, _ := s.debugger.GetRegisters()

	instrAddress := registers[s.processorConfig.PCRegister]

	builder := strings.Builder{}

	disassemble, _ := s.debugger.Disassemble()
	row := 0
	instrRow := -1
	for _, dis := range disassemble {
		bgColor := "[:black]"
		if dis.Address == instrAddress {
			bgColor = "[:red]"
			instrRow = row
		} else {
			_, ok := s.breakpointAddresses[dis.Address]
			if ok {
				bgColor = "[:blue]"
			}
		}
		builder.WriteString(fmt.Sprintf("%s%016x %s\n", bgColor, dis.Address, dis.Instruction))
		row = row + 1
	}
	s.disassemblyText.SetText(builder.String())
	if instrRow >= 0 {
		if instrRow > 3 {
			s.disassemblyText.ScrollTo(instrRow-3, 0)
		} else {
			s.disassemblyText.ScrollTo(0, 0)
		}
	}

	builder = strings.Builder{}

	mem := s.fetchMemoryBlocks()

	for _, b := range mem {
		builder.WriteString(fmt.Sprintf("%16x:  ", b.Address))

		ascImage := strings.Builder{}
		for i := 0; i < 8; i++ {
			builder.WriteString(fmt.Sprintf("%02x ", b.Data[i]))
			if b.Data[i] < 32 || b.Data[i] > 127 {
				ascImage.WriteString(".")
			} else {
				ascImage.WriteByte(b.Data[i])
			}
		}
		builder.WriteString(" ")
		builder.WriteString(ascImage.String())
		builder.WriteString("\n")
	}
	s.memoryText.SetText(builder.String())

	builder = strings.Builder{}

	for i, reg := range s.processorConfig.Registers {
		builder.WriteString(fmt.Sprintf("%3s: %016x  ", reg, registers[reg]))
		if i%2 == 1 {
			builder.WriteString("\n")
		}
	}
	s.registersText.SetText(builder.String())
}

func (s *Session) fetchMemoryBlocks() []MemoryBlock {
	currAddr := s.memoryPos

	memoryBlocks := []MemoryBlock{}

	for row := 0; row < 16; row += 8 {
		found := false
		for _, memBlock := range s.debugger.MemoryMap.Ranges {
			if currAddr < memBlock.Start {
				currAddr = memBlock.Start
				s.memoryPos = currAddr
				found = true
				break
			}
			if currAddr < memBlock.End {
				found = true
				break
			}
		}
		if !found {
			break
		}
		mem, err := s.debugger.GetMemory(currAddr, currAddr+64)
		if err != nil {
			break
		}

		for row8 := 0; row8 < 8; row8++ {
			memoryBlocks = append(memoryBlocks, MemoryBlock{Address: currAddr + uint64(row8*8), Data: mem[row8*8 : (row8+1)*8]})
		}
		currAddr += 64
	}
	return memoryBlocks
}

func (s *Session) updateMemoryPos(newPos uint64) {
	s.memoryPos = newPos
	s.updateDebuggingViews()
}
func (s *Session) handleMemoryTextKeyEvent(event *tcell.EventKey) *tcell.EventKey {
	switch event.Key() {
	case tcell.KeyCtrlB:
		s.updateMemoryPos(s.memoryPos - 128)
		return nil
	case tcell.KeyCtrlF:
		s.updateMemoryPos(s.memoryPos + 128)
		return nil
	case tcell.KeyUp:
		s.updateMemoryPos(s.memoryPos - 8)
		return nil
	case tcell.KeyDown:
		s.updateMemoryPos(s.memoryPos + 8)
		return nil
	case tcell.KeyLeft, tcell.KeyRight:
		return nil
	case tcell.KeyRune:
		switch event.Rune() {
		case 'h', 'H':
			return nil
		case 'l', 'L':
			return nil
		case 'j', 'J':
			s.updateMemoryPos(s.memoryPos + 8)
			return nil
		case 'k', 'K':
			s.updateMemoryPos(s.memoryPos - 8)
			return nil
		case 'p', 'P':
			s.updateMemoryPos(s.debugger.MemoryMap.ExecStart)
			return nil
		case 'd', 'D':
			s.updateMemoryPos(s.debugger.MemoryMap.DataStart)
			return nil
		case 's', 'S', 'G':
			regs, err := s.debugger.GetRegisters()
			if err == nil {
				s.updateMemoryPos(regs[s.processorConfig.SPRegister])
			}
			return nil
		case 'g', 'm', 'M':
			s.updateMemoryPos(s.debugger.MemoryMap.Ranges[0].Start)
			return nil
		}
	}
	return event
}

func (s *Session) writeCommandOutput(str string) {
	_, _ = s.commandsText.Write([]byte(str))
	s.commandsText.ScrollToEnd()
}

func (s *Session) handleCommand(command string) {
	if s.state != StateDebugging {
		s.writeCommandOutput("Commands not available when not debugging\n")
		return
	}
	s.commandsText.Write([]byte(command + "\n"))
	parts := strings.SplitN(command, " ", 2)
	switch parts[0] {
	case "b", "break":
		addr, err := strconv.ParseUint(parts[1], 16, 64)
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Unable to parse address: %+v\n", err))
			return
		}
		s.lastCommand = command
		err = s.debugger.SetBreakpoint(addr)
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Error setting breakpoint: %+v\n", err))
			return
		}
		s.writeCommandOutput(fmt.Sprintf("breakpoint set at %16x\n", addr))
	case "cb", "clear":
		addr, err := strconv.ParseUint(parts[1], 16, 64)
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Unable to parse address: %+v\n", err))
			return
		}
		s.lastCommand = command
		err = s.debugger.SetBreakpoint(addr)
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Error clearing breakpoint: %+v\n", err))
			return
		}
		s.writeCommandOutput(fmt.Sprintf("breakpoint cleared at %16x\n", addr))

	case "ca", "clearall":
		s.lastCommand = command
		err := s.debugger.ClearBreakpoints()
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Error clearing breakpoints: %+v", err))
			return
		}
		s.writeCommandOutput("All breakpoints cleared")
		s.updateDebuggingViews()
	case "s", "step":
		s.lastCommand = command
		err := s.debugger.Step()
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Error stepping: %+v", err))
			return
		}
	case "cont", "c":
		s.lastCommand = command
		err := s.debugger.Continue()
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Error continuing: %+v", err))
			return
		}
	case "solve":
		s.enterRunState()
	case "reset":
		s.restartDebugger()
	default:
		s.writeCommandOutput(fmt.Sprintf("Unknown command: %s\n"))
	}
}

func (s *Session) handlePromptInput(promptInput string) {
	if s.promptHexInput.IsChecked() {
		noSpaces := strings.Replace(promptInput, " ", "", -1)
		promptData, err := hex.DecodeString(noSpaces)
		if err != nil {
			s.doPopup(fmt.Sprintf("Invalid hex string - %+v", err), "OK")
			s.promptInput.SetText("")
		}
		_, _ = s.targetWrite(promptData)
		_, _ = s.targetWrite([]byte{10})
	} else {
		_, _ = s.targetWrite([]byte(promptInput))
		_, _ = s.targetWrite([]byte{10})
	}
}

func (s *Session) targetRead(buff []byte) (int, error) {
	if s.state == StateIdle {
		return -1, errors.New("can't read target program data while in idle state")
	} else if s.state == StateDebugging {
		return s.debugger.Session.Read(buff)
	} else if s.state == StateRunning {
		return s.stdout.Read(buff)
	}
	return -1, errors.New("can't read target program data while in unknown state")
}

func (s *Session) targetWrite(buff []byte) (int, error) {
	if s.state == StateIdle {
		return -1, errors.New("can't write target program data while in idle state")
	} else if s.state == StateDebugging {
		return s.debugger.Session.Write(buff)
	} else if s.state == StateRunning {
		return s.stdin.Write(buff)
	}
	return -1, errors.New("can't write target program data while in unknown state")
}

func (s *Session) targetReader() {
	buff := make([]byte, 1)
	for {
		_, err := s.targetRead(buff)
		if err != nil {
			go s.application.QueueUpdateDraw(func() {
				s.terminateTargetProgram()
			})
			return
		}

		if buff[0] == '?' {
			promptBuff := strings.Builder{}
			for {
				_, err := s.targetRead(buff)
				if err != nil {

					s.application.QueueUpdateDraw(func() {
						s.terminateTargetProgram()
					})
					return
				}
				if buff[0] == 0 {
					s.prompt = promptBuff.String()
					go s.application.QueueUpdateDraw(func() {
						s.gotoPrompt()
					})
					break
				} else {
					promptBuff.WriteByte(buff[0])
				}
			}
		} else if buff[0] == 'x' {
			s.application.QueueUpdateDraw(func() {
				s.gotoUnlockFailed()
			})
			return
		} else if buff[0] == '!' {
			s.application.QueueUpdateDraw(func() {
				s.gotoUnlockSucceeded()
			})
			return
		}
	}
}

func (s *Session) terminateTargetProgram() {
	if s.state == StateRunning {
		if s.command != nil {
			s.command.Process.Kill()
			s.command = nil
		}
	} else if s.state == StateDebugging {
		s.debugger.Session.Exit()
		s.debugger = nil
	}
	s.restartDebugger()
	s.application.SetRoot(s.ui, true)
	s.application.Draw()
	s.doPopup("Target program terminated unexpectedly", "OK")
}

func (s *Session) gotoUnlockFailed() {
	if s.state == StateRunning {
		if s.command != nil {
			s.command.Process.Kill()
			s.command = nil
		}
	} else if s.state == StateDebugging {
		s.debugger.Session.Exit()
		s.debugger = nil
	}
	s.restartDebugger()
	s.doPopup("Unlock failed", "OK")
}

func (s *Session) gotoUnlockSucceeded() {
	if s.state == StateRunning {
		if s.command != nil {
			s.command.Process.Kill()
			s.command = nil
		}
	} else if s.state == StateDebugging {
		s.debugger.Session.Exit()
		s.debugger = nil
	}
	s.state = StateIdle
	s.clearFields()
	s.doPopup("Unlock succeeded, Congratulations!", "OK")
}

func (s *Session) clearFields() {
	s.disassemblyText.SetText("")
	s.memoryText.SetText("")
	s.commandsText.SetText("")
	s.registersText.SetText("")
}

func (s *Session) gotoPrompt() {
	s.promptText.SetText(s.prompt)
	s.promptInput.SetText("")
	s.application.SetRoot(s.promptUi, true)
}

func (s *Session) enterRunState() {
	if s.state == StateDebugging {
		s.debugger.Session.Exit()
		s.debugger = nil
	}
	s.command = exec.Command(s.currentTarget.TargetName)
	s.stdin = s.command.Stdout
	s.stdout = s.command.Stdin

	go s.targetReader()
	s.command.Start()
}
