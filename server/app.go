package server

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/gorilla/websocket"
	"os"
)

type Session struct {
	debugger *Debugger
	process *os.Process
	conn *websocket.Conn
	running bool
}

type DebuggerMessage struct {
	MessageType string
	MessageBody json.RawMessage
}

type StartDebugMessage struct {
	App string
}

type StartRunMessage struct {
	App string
}

type StopMessage struct {

}

type PromptMessage struct {
	Prompt string
}

func handleMessages(conn *websocket.Conn) {
	defer conn.Close()
	session := &Session{
		conn: conn,
		running: true,
	}
	defer session.cleanup()

	for session.running {
		messageType, message, err := conn.ReadMessage()
		if err != nil {
			fmt.Printf("Got error reading message: %+v\n", err)
			return
		}

		if messageType == websocket.CloseMessage {
			return

		} else if messageType == websocket.TextMessage {
			messageWrapper := DebuggerMessage{}
			err = json.Unmarshal(message, &messageWrapper)

			if err != nil {
				fmt.Printf("Error decoding wrapped message %+v\n", err)
				return
			}

			switch messageWrapper.MessageType {
			case "StartDebug":
				msg := StartDebugMessage{}
				err = json.Unmarshal(messageWrapper.MessageBody, &msg)
				if err != nil {
					fmt.Printf("Error decoding message body: %+v", err)
					return
				}
				err = session.StartDebug(msg.App)
				if err != nil {
					fmt.Printf("Error starting debug session: %+v", err)
					return
				}

			case "StartRun":
				msg := StartRunMessage{}
				err = json.Unmarshal(messageWrapper.MessageBody, &msg)
				if err != nil {
					fmt.Printf("Error decoding message body: %+v", err)
					return
				}
				err = session.StartRun(msg.App)
				if err != nil {
					fmt.Printf("Error starting debug session: %+v", err)
					return
				}

			case "Stop":
				session.Stop()
			}
		}
	}
}

var validApps = map[string]string {
	"target1": "../target_programs/target1",
}

func (s *Session) StartDebug(app string) error {
	targetExe, ok := validApps[app]
	if !ok {
		return errors.New("Invalid app: "+app)
	}
	var err error
	s.debugger, err = NewSession(targetExe)
	if err != nil {
		return err
	}
	s.processIO = s.debugger.Session.

}

func (s *Session) StartRun(app string) error {

}

func (s *Session) Stop() error {

}

func (s *Session) ReadData() {
	ch := make([]byte, 1)
	for {
		n, err := s.debugger.Session.Read(ch)
		if n < 1 || err != nil {
			return
		}
		if ch[0] == '?' {
			prompt := make([]byte, 0)
			for {
				n, err = s.debugger.Session.Read(ch)
				if n < 1 || err != nil {
					return
				}
				if ch[0] == 0 {
					s.DoPrompt(string(prompt))
				} else {
					prompt = append(prompt, ch[0])
				}
			}
		} else if ch[0] == 'x' {
			s.DoUnlockFailed()
		} else if ch[0] == '!' {
			s.DoUnlockSuccess()
		}
	}
}

func (s *Session) cleanup() {
	if s.debugger != nil {
		s.debugger.Session.Exit()
	}
	if s.process != nil {
		s.process.Kill()
	}
}

func (s *Session) DoPrompt(prompt string) {
	msg := PromptMessage { Prompt: prompt }
	s.SendMessage("prompt", &msg)
}

func (s *Session) SendMessage(msgType string, msg interface{}) {
	msgBytes, _ := json.Marshal(msg)
	wrapper := DebuggerMessage {
		MessageType: msgType,
		MessageBody: msgBytes,
	}

	wrapperBytes, _ := json.Marshal(&wrapper)
	s.conn.WriteMessage(websocket.TextMessage, wrapperBytes)
}

