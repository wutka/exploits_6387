package server

import (
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/gorilla/websocket"
	"io"
	"os/exec"
)

type Session struct {
	debugger *Debugger
	command  *exec.Cmd
	stdin    io.WriteCloser
	stdout   io.ReadCloser
	conn     *websocket.Conn
	running  bool
}

type DebuggerMessage struct {
	MessageType string
	MessageBody json.RawMessage
}

type StartDebugMessage struct {
	App string
}

type StartRunMessage struct {
	App string
}

type StopMessage struct {
}

type PromptMessage struct {
	Prompt string
}

type UnlockMessage struct {
	Success bool
}

type InputMessage struct {
	Input string
	IsHex bool
}

type MemorySnapshot struct {
	Start  uint64
	End    uint64
	Memory []byte
}

type ReadMemoryMessage struct {
	Start uint64
	End   uint64
}

type InitialMachineState struct {
	Instructions []DisassembledInstruction
	Registers    map[string]uint64
	MemoryMap    MemoryMap
}

func HandleMessages(conn *websocket.Conn) {
	defer conn.Close()
	session := &Session{
		conn:    conn,
		running: true,
	}
	defer session.cleanup()

	for session.running {
		messageType, message, err := conn.ReadMessage()
		if err != nil {
			fmt.Printf("Got error reading message: %+v\n", err)
			return
		}

		if messageType == websocket.CloseMessage {
			return

		} else if messageType == websocket.TextMessage {
			messageWrapper := DebuggerMessage{}
			err = json.Unmarshal(message, &messageWrapper)

			if err != nil {
				fmt.Printf("Error decoding wrapped message %+v\n", err)
				return
			}

			fmt.Printf("Received message: %+s\n", string(message))
			switch messageWrapper.MessageType {
			case "StartDebug":
				msg := StartDebugMessage{}
				err = json.Unmarshal(messageWrapper.MessageBody, &msg)
				if err != nil {
					fmt.Printf("Error decoding message body: %+v", err)
					return
				}
				err = session.StartDebug(msg.App)
				if err != nil {
					fmt.Printf("Error starting debug session: %+v", err)
					return
				}
				session.SendMachineState()

			case "StartRun":
				msg := StartRunMessage{}
				err = json.Unmarshal(messageWrapper.MessageBody, &msg)
				if err != nil {
					fmt.Printf("Error decoding message body: %+v", err)
					return
				}
				err = session.StartRun(msg.App)
				if err != nil {
					fmt.Printf("Error starting run session: %+v", err)
					return
				}

			case "AcceptInput":
				msg := InputMessage{}

				err = json.Unmarshal(messageWrapper.MessageBody, &msg)
				if err != nil {
					fmt.Printf("Error decoding message body: %+v", err)
					return
				}
				err = session.AcceptInput(msg)
				if err != nil {
					fmt.Printf("Error accepting input: %+v", err)
					return
				}

			case "ReadMemory":
				msg := ReadMemoryMessage{}

				err = json.Unmarshal(messageWrapper.MessageBody, &msg)
				if err != nil {
					fmt.Printf("Error decoding message body: %+v", err)
					return
				}

				mem, err := session.debugger.GetMemory(msg.Start, msg.End)
				if err != nil {
					fmt.Printf("Error reading memory: %+v\n", err)
				}
				session.SendMessage("MemoryImage", mem)

			case "Stop":
				session.Stop()
			}
		}
	}
}

var validApps = map[string]string{
	"target1": "../target_programs/target1",
}

func (s *Session) StartDebug(app string) error {
	targetExe, ok := validApps[app]
	if !ok {
		return errors.New("Invalid app: " + app)
	}
	var err error
	s.debugger, err = NewSession(targetExe)
	if err != nil {
		return err
	}

	err = s.debugger.Debug()
	if err != nil {
		return err
	}

	go s.ReadData()
	return nil
}

func (s *Session) StartRun(app string) error {
	targetExe, ok := validApps[app]
	if !ok {
		return errors.New("Invalid app: " + app)
	}
	var err error

	s.command = exec.Command(targetExe)

	s.stdin, err = s.command.StdinPipe()
	if err != nil {
		return err
	}
	s.stdout, err = s.command.StdoutPipe()
	if err != nil {
		return err
	}

	err = s.command.Start()
	if err != nil {
		return err
	}

	go s.ReadData()
	return nil
}

func (s *Session) Stop() error {
	s.debugger.Session.Exit()
	return nil
}

func (s *Session) AcceptInput(input InputMessage) error {
	inputBytes := []byte(input.Input + "\n")
	var err error
	if input.IsHex {
		inputBytes, err = hex.DecodeString(input.Input)
		if err != nil {
			return err
		}
	}
	err = s.Write(inputBytes)
	return err
}

func (s *Session) Write(data []byte) error {
	var err error
	if s.debugger != nil {
		_, err = s.debugger.Session.Write(data)
		return err
	} else if s.stdin != nil {
		_, err = s.stdin.Write(data)
	} else {
		return errors.New("no instance is currently running")
	}
	if err != nil {
		fmt.Printf("Error writing: %+v\n", err)
	}
	return err
}

func (s *Session) Read(data []byte) (int, error) {
	if s.debugger != nil {
		return s.debugger.Session.Read(data)
	} else if s.stdout != nil {
		return s.stdout.Read(data)
	} else {
		return -1, errors.New("no instance is currently running")
	}
}

func (s *Session) ReadData() {
	ch := make([]byte, 1)
	for {
		n, err := s.Read(ch)
		if n < 1 || err != nil {
			fmt.Printf("Error reading from process: %+v\n", err)
			return
		}
		if ch[0] == '?' {
			prompt := make([]byte, 0)
			for {
				n, err = s.Read(ch)
				if n < 1 || err != nil {
					return
				}
				if ch[0] == 0 {
					fmt.Printf("Prompting with prompt: %s\n", string(prompt))
					s.DoPrompt(string(prompt))
					break
				} else {
					prompt = append(prompt, ch[0])
				}
			}
		} else if ch[0] == 'x' {
			s.DoUnlockFailed()
		} else if ch[0] == '!' {
			s.DoUnlockSuccess()
		}
	}
}

func (s *Session) cleanup() {
	if s.debugger != nil {
		_ = s.debugger.Session.Exit()
		s.debugger = nil
	}
	if s.command.Process != nil {
		_ = s.command.Process.Kill()
		_ = s.command.Wait()
		s.command = nil
		s.stdin = nil
		s.stdout = nil
	}
}

func (s *Session) DoPrompt(prompt string) {
	msg := PromptMessage{Prompt: prompt}
	s.SendMessage("Prompt", &msg)
}

func (s *Session) DoUnlockFailed() {
	msg := UnlockMessage{Success: false}
	s.SendMessage("Unlock", &msg)
}

func (s *Session) DoUnlockSuccess() {
	msg := UnlockMessage{Success: true}
	s.SendMessage("Unlock", &msg)
}

func (s *Session) SendMachineState() {
	if s.debugger == nil {
		fmt.Printf("Tried to send machine state while debugger isn't running\n")
		return
	}

	instructions, err := s.debugger.Disassemble()
	if err != nil {
		fmt.Printf("Error disassembling program: %+v\n", err)
		return
	}

	memMap, err := s.debugger.GetMemoryMap()
	if err != nil {
		fmt.Printf("Error getting memory map: %+v\n", err)
		return
	}

	registers, err := s.debugger.GetRegisters()
	if err != nil {
		fmt.Printf("Error getting registers: %+v\n", err)
		return
	}

	machineState := InitialMachineState{
		Instructions: instructions,
		Registers:    registers,
		MemoryMap:    memMap,
	}

	s.SendMessage("MachineState", &machineState)
}

func (s *Session) SendMessage(msgType string, msg interface{}) {
	msgBytes, _ := json.Marshal(msg)
	wrapper := DebuggerMessage{
		MessageType: msgType,
		MessageBody: msgBytes,
	}

	wrapperBytes, _ := json.Marshal(&wrapper)
	fmt.Printf("Sending web service message: %s\n", string(wrapperBytes))
	err := s.conn.WriteMessage(websocket.TextMessage, wrapperBytes)
	if err != nil {
		fmt.Printf("Error sending websocket message: %+v\n", err)
	}
}
