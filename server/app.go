package server

import (
	"encoding/hex"
	"errors"
	"fmt"
	"github.com/gdamore/tcell/v2"
	"github.com/rivo/tview"
	"math/rand"
	"strconv"
	"strings"
)

type TargetConfig struct {
	Title      string
	TargetName string
	ASLR       bool
}

type Config struct {
	Targets []TargetConfig
}

type ProcessorConfig struct {
	Registers  []string
	PCRegister string
	SPRegister string
}

type ProcConfig struct {
	Processors map[string]ProcessorConfig
}

type MemoryBlock struct {
	Address uint64
	Data    []byte
}

const (
	StateIdle = iota
	StateDebugging
	StateRunning
)

type Session struct {
	debugger      *Debugger
	state         int
	currentTarget TargetConfig

	application *tview.Application
	ui          tview.Primitive
	promptUi    tview.Primitive

	disassemblyText *tview.TextView
	memoryText      *tview.TextView
	registersText   *tview.TextView
	commandsText    *tview.TextView
	commandInput    *tview.InputField

	promptText     *tview.TextView
	promptInput    *tview.InputField
	promptHexInput *tview.Checkbox

	messageLine *tview.TextView

	memoryPos           uint64
	breakpointAddresses map[uint64]uint64
	instructions        []DisassembledInstruction
	disassemblyPos      int
	lastInstrPos        int

	processorConfig ProcessorConfig

	prompt      string
	lastCommand string

	randomPassword string
	promptActive   bool
	promptShowing  bool

	stopReading *bool
}

func RunApplication(config Config, procConfig ProcessorConfig) {
	session := &Session{
		state:           StateIdle,
		processorConfig: procConfig,
	}

	session.ui = session.InitializeUI(config)
	session.promptUi = session.InitializePromptUI(config)

	session.application = tview.NewApplication()
	session.application.EnableMouse(true)
	session.application.SetRoot(session.ui, true)
	session.application.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey {
		return session.handleApplicationKeyEvent(event)
	})

	if err := session.application.Run(); err != nil {
		panic(err)
	}

}

func (s *Session) InitializeUI(config Config) tview.Primitive {
	grid := tview.NewGrid().
		SetRows(1, 0, 1).
		SetColumns(140, 0)

	menuGrid := tview.NewGrid().
		SetRows(1).
		SetColumns(0)

	columnSizes := []int{}
	for _, target := range config.Targets {
		columnSizes = append(columnSizes, len(target.Title)+2)
	}
	columnSizes = append(columnSizes, 6, 0)
	menuGrid.SetColumns(columnSizes...)

	for i, target := range config.Targets {
		button := tview.NewButton(target.Title)
		pos := i
		button.SetSelectedFunc(func() {
			s.handleMenuButton(&config.Targets[pos])
		})
		menuGrid.AddItem(button, 0, i, 1, 1, 0, 0, false)
	}

	button := tview.NewButton("Exit")
	button.SetSelectedFunc(func() {
		s.application.Stop()
	})
	menuGrid.AddItem(button, 0, len(config.Targets), 1, 1, 0, 0, false)

	grid.AddItem(menuGrid, 0, 0, 1, 1, 0, 0, false)

	progGrid := tview.NewGrid().
		SetRows(20, 16, 1).
		SetColumns(90, 50, 0)

	s.disassemblyText = tview.NewTextView()
	s.disassemblyText.SetBorder(true)
	s.disassemblyText.SetTitle("Disassembly")
	s.disassemblyText.SetDynamicColors(true)
	s.disassemblyText.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey {
		return s.handleDisassemblyTextKeyEvent(event)
	})

	s.memoryText = tview.NewTextView()
	s.memoryText.SetBorder(true)
	s.memoryText.SetTitle("Memory")
	s.memoryText.SetDynamicColors(true)
	s.memoryText.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey {
		return s.handleMemoryTextKeyEvent(event)
	})

	s.registersText = tview.NewTextView()
	s.registersText.SetBorder(true)
	s.registersText.SetTitle("Registers")

	s.commandsText = tview.NewTextView()

	commandsGrid := tview.NewGrid()
	commandsGrid.SetBorder(true)
	commandsGrid.SetTitle("Commands")
	commandsGrid.SetRows(17, 1, 4, 0)
	commandsGrid.SetColumns(4, 0)
	commandsGrid.AddItem(s.commandsText, 0, 0, 1, 2, 0, 0, false)
	s.commandInput = tview.NewInputField()
	s.commandInput.SetDoneFunc(func(key tcell.Key) {
		if key == tcell.KeyEnter {
			s.handleCommand(s.commandInput.GetText())
			s.commandInput.SetText("")
		}
	})
	prompt := tview.NewTextView()
	prompt.SetText("Cmd:")
	commandsGrid.AddItem(prompt, 1, 0, 1, 1, 0, 0, false)
	commandsGrid.AddItem(s.commandInput, 1, 1, 1, 1, 0, 0, false)

	progGrid.AddItem(s.disassemblyText, 0, 0, 1, 1, 0, 0, false)
	progGrid.AddItem(s.memoryText, 1, 0, 1, 1, 0, 0, false)
	progGrid.AddItem(commandsGrid, 0, 1, 1, 1, 0, 0, false)
	progGrid.AddItem(s.registersText, 1, 1, 1, 1, 0, 0, false)

	grid.AddItem(progGrid, 1, 0, 1, 1, 0, 0, false)

	s.messageLine = tview.NewTextView()
	grid.AddItem(s.messageLine, 2, 0, 1, 1, 0, 0, false)

	return grid
}

func (s *Session) InitializePromptUI(config Config) tview.Primitive {
	grid := tview.NewGrid().
		SetRows(10, 3, 1, 0).
		SetColumns(0)

	s.promptText = tview.NewTextView()
	s.promptText.SetBorder(true)
	grid.AddItem(s.promptText, 0, 20, 1, 40, 0, 0, false)

	s.promptInput = tview.NewInputField()
	s.promptInput.SetDoneFunc(func(key tcell.Key) {
		if key == tcell.KeyEnter {
			s.handlePromptInput(s.promptInput.GetText())
		}
	})
	grid.AddItem(s.promptInput, 1, 20, 1, 40, 0, 0, true)

	s.promptHexInput = tview.NewCheckbox()
	s.promptHexInput.SetLabel("Check here to enable hex input")
	grid.AddItem(s.promptHexInput, 2, 20, 1, 40, 0, 0, false)

	return grid
}

func (s *Session) doYesNoPopup(prompt string, okText string, cancelText string, handlerFunc func(*Session, bool)) {
	modal := tview.NewModal().
		SetText(prompt).
		AddButtons([]string{okText, cancelText}).
		SetDoneFunc(func(buttonIndex int, buttonLabel string) {
			s.application.SetRoot(s.ui, true)
			handlerFunc(s, buttonIndex == 0)
		})
	s.application.SetRoot(modal, true)
}

func (s *Session) doPopup(prompt string, okText string) {
	modal := tview.NewModal().
		SetText(prompt).
		AddButtons([]string{okText}).
		SetDoneFunc(func(buttonIndex int, buttonLabel string) {
			s.application.SetRoot(s.ui, true)
		})
	s.application.SetRoot(modal, true)
}

func (s *Session) handleMenuButton(target *TargetConfig) {
	if s.state != StateIdle {
		if target.Title != s.currentTarget.Title {
			verb := "debugging"
			if s.state == StateRunning {
				verb = "running"
			}

			prompt := fmt.Sprintf("Stop %s target %s and switch to target %s?",
				verb, s.currentTarget.Title,
				target.Title)

			s.doYesNoPopup(prompt, "Yes", "No", func(s *Session, switchOk bool) {
				if switchOk {
					s.changeDebugTarget(*target)
				}
				return
			})
		}
	}
	s.changeDebugTarget(*target)
}

var passwordChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-_?!.,"

func generateRandomPassword() string {
	numChars := 8 + rand.Intn(8)
	builder := strings.Builder{}
	for i := 0; i < numChars; i++ {
		builder.WriteByte(passwordChars[rand.Intn(len(passwordChars))])
	}
	return builder.String()
}

func (s *Session) changeDebugTarget(target TargetConfig) {
	if s.debugger != nil {
		_ = s.debugger.Session.Exit()
		s.debugger = nil
	}

	s.randomPassword = generateRandomPassword()
	s.breakpointAddresses = map[uint64]uint64{}
	s.currentTarget = target

	s.restartDebugger()
}

func (s *Session) restartDebugger() {
	debugger, err := NewSession(s.currentTarget.TargetName, s.processorConfig,
		s.currentTarget.ASLR,
		func() {
			go s.application.QueueUpdateDraw(func() {
				s.updateDebuggingViews()
			})
		})
	if err != nil {
		s.doPopup(fmt.Sprintf("Error debugging target %s: %+v", s.currentTarget.TargetName, err),
			"Ok")
		s.state = StateIdle
		return
	}

	s.debugger = debugger
	s.clearBreakpoints()
	s.state = StateDebugging
	err = s.debugger.Debug()
	if err != nil {
		s.doPopup(fmt.Sprintf("Error debugging target %s: %+v", s.currentTarget.TargetName, err),
			"Ok")
		s.state = StateIdle
		return
	}

	stopFlag := false
	s.stopReading = &stopFlag
	go s.targetReader(&stopFlag)

	s.memoryPos = s.debugger.MemoryMap.Ranges[0].Start
	s.disassemblyPos = -1

	s.updateDebuggingViews()
}

func (s *Session) clearBreakpoints() {
	s.breakpointAddresses = map[uint64]uint64{}
}

func (s *Session) updateDebuggingViews() {
	if s.state != StateDebugging {
		return
	}
	registers, _ := s.debugger.GetRegisters()

	instrAddress := registers[s.processorConfig.PCRegister]

	builder := strings.Builder{}

	s.instructions, _ = s.debugger.Disassemble()
	row := 0
	instrRow := -1
	for i, dis := range s.instructions {
		bgColor := "[white:black]"
		if dis.Address == instrAddress {
			bgColor = "[white:red]"
			instrRow = row
		} else {
			_, ok := s.breakpointAddresses[dis.Address]
			if ok {
				bgColor = "[white:blue]"
			}
		}
		if i == s.disassemblyPos {
			bgColor = "[black:yellow]"
		}
		builder.WriteString(fmt.Sprintf("%s%016x %20s %s\n", bgColor, dis.Address, dis.Opcodes, dis.Instruction))
		row = row + 1
	}
	s.disassemblyText.SetText(builder.String())
	s.lastInstrPos = instrRow
	if instrRow >= 0 && s.disassemblyPos < 0 {
		if instrRow > 7 {
			s.disassemblyText.ScrollTo(instrRow-7, 0)
		} else {
			s.disassemblyText.ScrollTo(0, 0)
		}
	} else if s.disassemblyPos >= 0 {
		if s.disassemblyPos > 7 {
			s.disassemblyText.ScrollTo(s.disassemblyPos-7, 0)
		} else {
			s.disassemblyText.ScrollTo(0, 0)
		}
	}

	builder = strings.Builder{}

	mem := s.fetchMemoryBlocks()

	for _, b := range mem {
		builder.WriteString(fmt.Sprintf("%16x:  ", b.Address))

		ascImage := strings.Builder{}
		for i := 0; i < 8; i++ {
			builder.WriteString(fmt.Sprintf("%02x ", b.Data[i]))
			if b.Data[i] < 32 || b.Data[i] > 127 {
				ascImage.WriteString(".")
			} else {
				ascImage.WriteByte(b.Data[i])
			}
		}
		builder.WriteString(" ")
		builder.WriteString(ascImage.String())
		builder.WriteString("\n")
	}
	s.memoryText.SetText(builder.String())

	builder = strings.Builder{}

	for i, reg := range s.processorConfig.Registers {
		builder.WriteString(fmt.Sprintf("%3s: %016x  ", reg, registers[reg]))
		if i%2 == 1 {
			builder.WriteString("\n")
		}
	}
	s.registersText.SetText(builder.String())
}

func (s *Session) fetchMemoryBlocks() []MemoryBlock {
	currAddr := s.memoryPos

	memoryBlocks := []MemoryBlock{}

	for row := 0; row < 16; row += 8 {
		found := false
		for _, memBlock := range s.debugger.MemoryMap.Ranges {
			if currAddr < memBlock.Start {
				currAddr = memBlock.Start
				s.memoryPos = currAddr
				found = true
				break
			}
			if currAddr < memBlock.End {
				found = true
				break
			}
		}
		if !found {
			break
		}
		mem, err := s.debugger.GetMemory(currAddr, currAddr+64)
		if err != nil {
			break
		}

		for row8 := 0; row8 < 8; row8++ {
			memoryBlocks = append(memoryBlocks, MemoryBlock{Address: currAddr + uint64(row8*8), Data: mem[row8*8 : (row8+1)*8]})
		}
		currAddr += 64
	}
	return memoryBlocks
}

func (s *Session) updateMemoryPos(newPos uint64) {
	s.memoryPos = newPos
	s.updateDebuggingViews()
}

func (s *Session) handleApplicationKeyEvent(event *tcell.EventKey) *tcell.EventKey {
	switch event.Key() {
	case tcell.KeyTab:
		if s.promptActive {
			if s.promptShowing {
				s.application.SetRoot(s.ui, true)
				s.promptShowing = false
			} else {
				s.application.SetRoot(s.promptUi, true)
				s.promptShowing = true
			}
		}
		return nil
	default:
		return event
	}
}

func (s *Session) handleMemoryTextKeyEvent(event *tcell.EventKey) *tcell.EventKey {
	switch event.Key() {
	case tcell.KeyCtrlB:
		s.updateMemoryPos(s.memoryPos - 128)
		return nil
	case tcell.KeyCtrlF:
		s.updateMemoryPos(s.memoryPos + 128)
		return nil
	case tcell.KeyUp:
		s.updateMemoryPos(s.memoryPos - 8)
		return nil
	case tcell.KeyDown:
		s.updateMemoryPos(s.memoryPos + 8)
		return nil
	case tcell.KeyLeft, tcell.KeyRight:
		return nil
	case tcell.KeyRune:
		switch event.Rune() {
		case 'h', 'H':
			return nil
		case 'l', 'L':
			return nil
		case 'j', 'J':
			s.updateMemoryPos(s.memoryPos + 8)
			return nil
		case 'k', 'K':
			s.updateMemoryPos(s.memoryPos - 8)
			return nil
		case 'p', 'P':
			s.updateMemoryPos(s.debugger.MemoryMap.ExecStart)
			return nil
		case 'd', 'D':
			s.updateMemoryPos(s.debugger.MemoryMap.DataStart)
			return nil
		case 's', 'S', 'G':
			regs, err := s.debugger.GetRegisters()
			if err == nil {
				s.updateMemoryPos(regs[s.processorConfig.SPRegister])
			}
			return nil
		case 'g', 'm', 'M':
			s.updateMemoryPos(s.debugger.MemoryMap.Ranges[0].Start)
			return nil
		}
	}
	return event
}

func (s *Session) handleDisassemblyTextKeyEvent(event *tcell.EventKey) *tcell.EventKey {
	switch event.Key() {
	case tcell.KeyCtrlB:
		if s.disassemblyPos < 0 {
			s.disassemblyPos = s.lastInstrPos - 10
		} else {
			s.disassemblyPos -= 10
		}
		if s.disassemblyPos < 0 {
			s.disassemblyPos = 0
		}
		s.updateDebuggingViews()
		return nil
	case tcell.KeyUp:
		if s.disassemblyPos < 0 {
			s.disassemblyPos = s.lastInstrPos - 1
		} else {
			s.disassemblyPos -= 1
		}
		if s.disassemblyPos < 0 {
			s.disassemblyPos = 0
		}
		s.updateDebuggingViews()
		return nil
	case tcell.KeyCtrlF:
		if s.disassemblyPos < 0 {
			s.disassemblyPos = s.lastInstrPos + 10
		} else {
			s.disassemblyPos += 10
		}
		if s.disassemblyPos >= len(s.instructions) {
			s.disassemblyPos = len(s.instructions) - 1
		}
		s.updateDebuggingViews()
		return nil
	case tcell.KeyDown:
		if s.disassemblyPos < 0 {
			s.disassemblyPos = s.lastInstrPos + 1
		} else {
			s.disassemblyPos += 1
		}
		if s.disassemblyPos >= len(s.instructions) {
			s.disassemblyPos = len(s.instructions) - 1
		}
		s.updateDebuggingViews()
		return nil
	case tcell.KeyRune:
		switch event.Rune() {
		case 'j', 'J':
			if s.disassemblyPos < 0 {
				s.disassemblyPos = s.lastInstrPos + 1
			} else {
				s.disassemblyPos += 1
			}
			if s.disassemblyPos >= len(s.instructions) {
				s.disassemblyPos = len(s.instructions) - 1
			}
			s.updateDebuggingViews()
			return nil
		case 'k', 'K':
			if s.disassemblyPos < 0 {
				s.disassemblyPos = s.lastInstrPos - 1
			} else {
				s.disassemblyPos -= 1
			}
			if s.disassemblyPos < 0 {
				s.disassemblyPos = 0
			}
			s.updateDebuggingViews()
			return nil
		case 'b', 'B':
			bpAddr := s.instructions[s.disassemblyPos].Address
			_, ok := s.breakpointAddresses[bpAddr]
			if ok {
				_ = s.debugger.ClearBreakpoint(bpAddr)
				delete(s.breakpointAddresses, bpAddr)
			} else {
				_ = s.debugger.SetBreakpoint(bpAddr)
				s.breakpointAddresses[bpAddr] = bpAddr
			}
			s.updateDebuggingViews()
			return nil

		case 'i', 'I':
			s.disassemblyPos = s.lastInstrPos
			s.updateDebuggingViews()
			return nil
		}
	}
	return event
}

func (s *Session) writeCommandOutput(str string) {
	_, _ = s.commandsText.Write([]byte(str))
	s.commandsText.ScrollToEnd()
}

func (s *Session) handleCommand(command string) {
	if s.state != StateDebugging {
		s.writeCommandOutput("Commands not available when not debugging\n")
		return
	}
	if len(command) == 0 {
		command = s.lastCommand
	}
	s.commandsText.Write([]byte(command + "\n"))
	parts := strings.SplitN(command, " ", 2)
	switch parts[0] {
	case "b", "break":
		addr, err := strconv.ParseUint(parts[1], 16, 64)
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Unable to parse address: %+v\n", err))
			return
		}
		s.lastCommand = command
		err = s.debugger.SetBreakpoint(addr)
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Error setting breakpoint: %+v\n", err))
			return
		}
		s.writeCommandOutput(fmt.Sprintf("breakpoint set at %16x\n", addr))
		s.breakpointAddresses[addr] = addr
	case "cb", "clear":
		addr, err := strconv.ParseUint(parts[1], 16, 64)
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Unable to parse address: %+v\n", err))
			return
		}
		s.lastCommand = command
		err = s.debugger.ClearBreakpoint(addr)
		_, ok := s.breakpointAddresses[addr]
		if ok {
			delete(s.breakpointAddresses, addr)
		}
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Error clearing breakpoint: %+v\n", err))
			return
		}
		s.writeCommandOutput(fmt.Sprintf("breakpoint cleared at %16x\n", addr))

	case "ca", "clearall":
		s.lastCommand = command
		err := s.debugger.ClearBreakpoints()
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Error clearing breakpoints: %+v", err))
			return
		}
		s.writeCommandOutput("All breakpoints cleared")
		s.breakpointAddresses = map[uint64]uint64{}
		s.updateDebuggingViews()
	case "s", "step":
		s.lastCommand = command
		err := s.debugger.Step()
		s.disassemblyPos = -1
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Error stepping: %+v", err))
			return
		}
	case "n", "next":
		s.lastCommand = command
		err := s.debugger.Next()
		s.disassemblyPos = -1
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Error stepping over: %+v", err))
			return
		}
	case "cont", "c":
		s.lastCommand = command
		err := s.debugger.Continue()
		s.disassemblyPos = -1
		if err != nil {
			s.writeCommandOutput(fmt.Sprintf("Error continuing: %+v", err))
			return
		}
	case "view", "v":
		if len(parts) < 2 {
			s.writeCommandOutput(fmt.Sprintf("view requires a function name"))
			return
		}
		for i, inst := range s.instructions {
			if strings.HasSuffix(inst.Instruction, "# "+parts[1]) {
				s.disassemblyPos = i
				s.updateDebuggingViews()
				return
			}
		}

	case "solve":
		s.enterRunState()
	case "reset":
		s.restartDebugger()
	default:
		s.writeCommandOutput(fmt.Sprintf("Unknown command: %s\n", command))
	}
}

func (s *Session) handlePromptInput(promptInput string) {
	if s.promptHexInput.IsChecked() {
		noSpaces := strings.Replace(promptInput, " ", "", -1)
		promptData, err := hex.DecodeString(noSpaces)
		if err != nil {
			s.doPopup(fmt.Sprintf("Invalid hex string - %+v", err), "OK")
			s.promptInput.SetText("")
		}
		_, _ = s.targetWrite(promptData)
		_, _ = s.targetWrite([]byte{10})
	} else {
		_, _ = s.targetWrite([]byte(promptInput))
		_, _ = s.targetWrite([]byte{10})
	}
}

func (s *Session) targetRead(buff []byte) (int, error) {
	if s.state == StateIdle {
		return -1, errors.New("can't read target program data while in idle state")
	} else if s.state == StateDebugging || s.state == StateRunning {
		return s.debugger.Session.Read(buff)
	}
	return -1, errors.New("can't read target program data while in unknown state")
}

func (s *Session) targetWrite(buff []byte) (int, error) {
	if s.state == StateIdle {
		return -1, errors.New("can't write target program data while in idle state")
	} else if s.state == StateDebugging || s.state == StateRunning {
		return s.debugger.Session.Write(buff)
	}
	return -1, errors.New("can't write target program data while in unknown state")
}

func (s *Session) targetReader(stopFlag *bool) {
	buff := make([]byte, 1)
	for !*stopFlag {
		_, err := s.targetRead(buff)
		if err != nil {
			go s.application.QueueUpdateDraw(func() {
				if !*stopFlag {
					s.terminateTargetProgram()
				}
			})
			return
		}

		if buff[0] == '?' {
			promptBuff := strings.Builder{}
			for {
				_, err := s.targetRead(buff)
				if err != nil {

					s.application.QueueUpdateDraw(func() {
						if !*stopFlag {
							s.terminateTargetProgram()
						}
					})
					return
				}
				if buff[0] == 0 {
					s.prompt = promptBuff.String()
					go s.application.QueueUpdateDraw(func() {
						s.gotoPrompt()
					})
					break
				} else {
					promptBuff.WriteByte(buff[0])
				}
			}
		} else if buff[0] == 'p' {
			promptBuff := strings.Builder{}
			for {
				_, err := s.targetRead(buff)
				if err != nil {
					s.application.QueueUpdateDraw(func() {
						if !*stopFlag {
							s.terminateTargetProgram()
						}
					})
					return
				}
				if buff[0] == 0 {
					if promptBuff.String() == s.randomPassword {
						buff[0] = 1
					} else {
						buff[0] = 0
					}
					s.targetWrite(buff)
					break
				} else {
					promptBuff.WriteByte(buff[0])
				}
			}
		} else if buff[0] == 'x' {
			s.application.QueueUpdateDraw(func() {
				s.gotoUnlockFailed()
			})
			return
		} else if buff[0] == '!' {
			s.application.QueueUpdateDraw(func() {
				s.gotoUnlockSucceeded()
			})
			return
		}
	}
}

func (s *Session) terminateTargetProgram() {
	if s.stopReading != nil {
		*s.stopReading = true

	}
	if s.state == StateRunning {
		s.debugger.Session.Exit()
		s.debugger = nil
	} else if s.state == StateDebugging {
		s.debugger.Session.Exit()
		s.debugger = nil
	}
	s.restartDebugger()
	s.application.SetRoot(s.ui, true)
	s.application.Draw()
	s.doPopup("Target program terminated unexpectedly", "OK")
}

func (s *Session) gotoUnlockFailed() {
	s.promptActive = false
	s.promptShowing = false
	if s.state == StateRunning {
		s.debugger.Session.Exit()
		s.debugger = nil
	} else if s.state == StateDebugging {
		s.debugger.Session.Exit()
		s.debugger = nil
	}
	s.restartDebugger()
	s.doPopup("Unlock failed", "OK")
}

func (s *Session) gotoUnlockSucceeded() {
	s.promptActive = false
	s.promptShowing = false
	if s.state == StateRunning {
		s.debugger.Session.Exit()
		s.debugger = nil
	} else if s.state == StateDebugging {
		s.debugger.Session.Exit()
		s.debugger = nil
	}
	s.state = StateIdle
	s.clearFields()
	s.doPopup("Unlock succeeded, Congratulations!", "OK")
}

func (s *Session) clearFields() {
	s.disassemblyText.SetText("")
	s.memoryText.SetText("")
	s.commandsText.SetText("")
	s.registersText.SetText("")
}

func (s *Session) gotoPrompt() {
	s.promptActive = true
	s.promptShowing = true
	s.promptText.SetText(s.prompt)
	s.promptInput.SetText("")
	s.application.SetRoot(s.promptUi, true)
}

func (s *Session) enterRunState() {
	if s.state == StateDebugging {
		s.state = StateIdle
		*s.stopReading = true
		err := s.debugger.Session.Exit()
		if err != nil {
			s.messageLine.SetText(fmt.Sprintf("Error stopping GDB: %+v", err))
		}
		s.debugger = nil
	}

	s.state = StateRunning

	debugger, err := NewSession(s.currentTarget.TargetName, s.processorConfig,
		s.currentTarget.ASLR,
		func() {
			go s.application.QueueUpdateDraw(func() {
				s.updateDebuggingViews()
			})
		})
	if err != nil {
		s.doPopup(fmt.Sprintf("Error running target %s: %+v", s.currentTarget.TargetName, err),
			"Ok")
		s.state = StateIdle
		return
	}

	s.debugger = debugger
	s.clearBreakpoints()
	err = s.debugger.Run()
	if err != nil {
		s.doPopup(fmt.Sprintf("Error running target %s: %+v", s.currentTarget.TargetName, err),
			"Ok")
		s.state = StateIdle
		return
	}

	stopFlag := false
	s.stopReading = &stopFlag
	go s.targetReader(&stopFlag)
}
