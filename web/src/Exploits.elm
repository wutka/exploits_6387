port module Exploits exposing (main)

import Array exposing (Array)
import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Json.Decode exposing (..)

type Msg 
  = IncomingMsg Json.Decode.Value

type alias Instruction =
  {
    address : Int
  , instruction : String
  }

instructionDecoder : Decoder Instruction
instructionDecoder =
  map2 Instruction (field "Address" int) (field "Instruction" string)

type alias Register =
  {
    name : String
  , value : Int
  }

registerDecoder : Decoder Register
registerDecoder =
  map2 Register (field "Name" string) (field "Value" int)

type alias MemoryRange =
  {
    start : Int
  , end : Int
  }

memoryRangeDecoder : Decoder MemoryRange
memoryRangeDecoder =
  map2 MemoryRange (field "Start" int) (field "End" int)

type alias MemoryMap =
  {
    execStart : Int
  , execEnd : Int
  , dataStart : Int
  , dataEnd : Int
  , stackStart : Int
  , stackEnd : Int
  , ranges : List MemoryRange
  }

memoryMapDecoder : Decoder MemoryMap
memoryMapDecoder =
  map7 MemoryMap (field "ExecStart" int) (field "ExecEnd" int)
       (field "DataStart" int) (field "DataEnd" int)
       (field "StackStart" int) (field "StackEnd" int)
       (field "Ranges" (Json.Decode.list memoryRangeDecoder))

type alias MachineState =
  {
    instructions : Array Instruction
  , registers : Array Register
  , memoryMap : MemoryMap
  }

machineStateDecoder : Decoder MachineState
machineStateDecoder =
  map3 MachineState
       (field "Instructions" (array instructionDecoder))
       (field "Registers" (array registerDecoder))
       (field "MemoryMap" memoryMapDecoder)

type alias Model = 
  {
    machineState : MachineState
  }

type alias MessageWrapper =
  {
    messageType : String
  , messageBody : String
  }

messageWrapperDecoder : Decoder MessageWrapper
messageWrapperDecoder =
  map2 MessageWrapper (field "MessageType" string) (field "MessageBody" string)

init : () -> (Model, Cmd Msg)
init _ =
  ({ machineState =
      { instructions = Array.fromList []
      , registers = Array.fromList []
      , memoryMap =
        {
          execStart = 0
        , execEnd = 0
        , dataStart = 0
        , dataEnd = 0
        , stackStart = 0
        , stackEnd = 0
        , ranges = []
        }
       }
  }
   , Cmd.none)

port websocketIn : (Json.Decode.Value -> msg) -> Sub msg
port websocketOut : String -> Cmd msg

viewDisassembled : Instruction -> Html Msg
viewDisassembled inst =
    pre [class "code"] [text inst.instruction]
    
view : Model -> Html Msg
view model =
    div [] [ div [] [
                      div [id "disasm", class "disasmgrid"] 
                        (List.map viewDisassembled model.instructions)
                    , div [id "registers", class "reggrid"] []
                    ]
           , div [] [
                      div [id "memory", class "memgrid"] []
                    , div [id "command", class "cmdgrid"] []
                    ]
           ]

handleIncomingMessage : Model -> MessageWrapper -> Model
handleIncomingMessage model messageWrapper =
  case messageWrapper.messageType of
    "MachineState" -> 
      case Json.Decode.decodeString machineStateDecoder messageWrapper.messageBody of
         Ok machineState -> { model | machineState = machineState }
         Err _ -> model
    _ -> model

update msg model = 
    case msg of
        IncomingMsg payload ->
            case Json.Decode.decodeValue messageWrapperDecoder payload of
                Ok messageWrapper -> (handleIncomingMessage model messageWrapper, Cmd.none)
                Err message ->
                    (model, Cmd.none)

subscriptions : Model -> Sub Msg
subscriptions model =
    websocketIn IncomingMsg

main = Browser.element
    { init = init
    , view = view
    , update = update
    , subscriptions = subscriptions
    }

