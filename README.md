# Capture-the-Flag - Disassembly & Exploitation

This code is my final project for Vanderbilt CS 6387 Topics in Software Engineering - Security.
It was inspired by the Capture-the-Flag trainer at https://microcorruption.com, but I wanted mine
to use 64-bit processors instead of the TI MSP430 used by the Microcorruption site.
The basic premise is the same - you are given a program that prompts you for a password and
interacts with an electronic lock. Your goal is to unlock the lock.

There are 6 targets to try ranging in difficulty. The features of the 6 targets are:

## 1 - Ready-to-Go
The Target 1 lock is a system where you just connect up the lock and it is ready to go. You don't even
have to set an initial password since the system comes pre-configured with one.

## 2 - Even More Ready, No Trickery!
Target 2 is an improvement over Target 1. You may have heard rumors of people finding the Target 1 password
somewhere in the code for the lock, but you don't need to worry about that with target 2, because the
password is hidden mathematically.

## 3 - AES256 Strong
Target 3 uses state-of-the-art AES 256-bit security to protect its passwordÂ¸so no simple math tricks will
break this encryption!

## 4 - The Password Lockbox
What's better than using AES 256-bit security to protect the password? Not even keeping the password on the
system in the first place! Target 4 features a redesigned lock in which the lock is securely stored in the
lock itself and not in the computer controlling it. You can no longer get to the password through the
computer, and the lock now makes the determination whether or not the password is correct.

## 5 - The Simple-is-better Password Lockbox
We discovered a potential flaw in Target 4 where a variable might be tampered with to trick the system into
opening the lock. We simplified our algorithm so this is no longer possible and the lock is even more secure.

## 6 - Safer, Less Jumpy
Some locks might be vulnerable to jumping around in the code and causing the lock to unlock, but not this one.
A special interlocking mechanism prevents someone from causing the password program to jump to the wrong location.

(Note: If you are trying Target 6 on the ARM64 processor, you may find that it is hard to attack because of the
simplicity of the program, the way it interacts with the server, and the way ARM64 stores return addresses.
The Target6-Arm target adds an extra layer of function calls to facilitate exploits)


# Building and Running
There are two components to the system - the targets and the server/debugger. To build the target programs and the server/debugger, you need the GCC compiler, make, a recent version of Go, and GDB. On a Debian system, you
should be able to get these with:
```shell
sudo apt install build-essential gdb golang-go
```

### Building the targets
In the target\_programs directory is a Makefile, you should just be able to do:
```shell
make
```

### Building the server
The server is written in Go, so you need a recent version of Go installed, one that supports the module system. I used 1.16.
You can build the server with this command from the server directory:
```shell
go build -o server main/main.go

### Running the server
You'll need GDB installed. On a Debian-based system (including Ubuntu and Linux Mint) you can do:
```shell
sudo apt install gdb
```

Then, just run the server:
```shell
./server
```

You should see a screen like this:
![Debugger screen](img/server1.png)

## Running Targets
To run a target, just click on the target name at the top of the screen. If you click on Target1, it should
look something like this:
![Debugger screen running target](img/server2.png)

### Navigation Commands
To scroll through the memory and disassembly windows.

#### Disassembly Window
You can use the following keys to navigate the disassembly window:

|Keystroke    |Result                            |
|-------------|----------------------------------|
|Control-B    |Scroll back 10 lines              |
|Control-F    |Scroll forward 10 lines           |
|Up or k      |Scroll back 1 line                |
|Down or j    |Scroll forward 1 line             |
|b            |Toggle breakpoint on current line |
|i            |Jump to current instruction       |


#### Memory Window
You can use the following keys to navigate the memory window:
|Keystroke    |Result                                      |
|-------------|--------------------------------------------|
|Control-B    |Scroll back 10 lines                        |
|Control-F    |Scroll forward 10 lines                     |
|Up or k      |Scroll back 1 line                          |
|Down or j    |Scroll forward 1 line                       |
|p            |Jump to beginning of program memory         |
|d            |Jump to beginning of program data           |
|s, S, or G   |Jump to beginning of stack memory           |
|m, M or g    |Jump to lowest memory location              |

#### Command Window
In the command window on the right-hand side, you can enter additional
commands:

|Command            |Result                                         |
|-------------------|-----------------------------------------------|
| b addr            |Set a breakpoint at the given address or symbol|
| b symbol          |Set a breakpoint at the given address or symbol|
| break addr        |Set a breakpoint at the given address or symbol|
| break symbo       |Set a breakpoint at the given address or symbol|
| cb addr           |Clear a breakpoint at the given address        |
| clear addr        |Clear a breakpoint at the given address        |
| ca                |Clear all breakpoints                          |
| clearall          |Clear all breakpoints                          |
| s or step         |Step into the next instruction, if it is a function, step into the function |
| n or next         |Step over the next instruction, if it is a function, step over the function |
| c or cont         |Continue executing until a breakpoint or termination |
| v function        |Scroll to the named function in the disassembly window |
| view function     |Scroll to the named function in the disassembly window |
| vm addr           |Scroll to the given address in the memory window |
| viewmem addr      |Scroll to the given address in the memory window |
| solve             |Run the program outside of debugging to be sure you can open the lock without the debugger|
| reset             |Reset the program to the beginning and clear breakpoints |

#### Switching between password prompt and debugger
If the password prompt is being displayed and the debugger hits a
breakpoint, it should now automatically switch back to the debugger,
but if it doesn't, the tab key will toggle back and forth between
the password prompt and the debugger. If the program is running,
however, you will not be able to interact with the debugger and
attempting to do so may cause it to lock up.

## Solution Videos
I have made some Youtube videos walking through each of these solutions, as well as one for Target 8,
for which I don't have a solution, but instead an explanation of why I don't have a solution for it.
You can view them [here](https://www.youtube.com/playlist?list=PLOc_FZ5lfpGt6su7Xxu5zE9O94BQpX77U).

## Other Platforms
Most users will probably run these targets on an X86-64 machine, and the Youtube videos showing how
to solve them are based on the X86-64. However, the server knows how to do ARM64 and Riscv-64 processors
as well. You will need the Qemu system emulator installed on a Linux system in order to run these virtual machines.
Each virtual machine is roughly 1.5GB in size before downloading and 3-4GB when unzipped.

There are virtual machines available for the following processor architectures:
[ARM64](http://www.wutka.com/download/exploits_aarch64.zip)
[RISCV-64](http://www.wutka.com/download/exploits_riscv64.zip)

When Qemu is emulating a processor that is different from the underlying hardware, it tends to be much slowing
than running on the actual hardware. You should expect the system to be fairly sluggish - like when you click
on a particular target, it may be 10-20 seconds before the program actually appears.

### ARM64
Once you download a the ARM64 zip file:
```shell
unzip exploits_aarch64.zip
cd exploits_aarch64
./run-aarch64
```
The run-aarch64 command will start Qemu, but you probably want to SSH into it from a separate terminal window
in order to run the simulator. Open another window, resize it to be fairly wide and tall and do:
```shell
ssh -p 2222 debian@localhost
cd exploits_aarch64/server
./server
```

Remember that you may not be able to adequately exploit a buffer overflow on Target 6 and may need
to use Target6-Arm on the ARM64 processor.

### RISCV-64
Once you download a the ARM64 zip file:
```shell
unzip exploits_riscv64.zip
cd exploits_riscv64
./run-riscv64
```
The run-riscv64 command will start Qemu, but you probably want to SSH into it from a separate terminal window
in order to run the simulator. Open another window, resize it to be fairly wide and tall and do:
```shell
ssh -p 2222 debian@localhost
cd exploits_riscv64/server
./server
```

## How to Approach the Problems
Trying to exploit a program by looking at the disassembled code is not
a simple task, but it can be a rewarding exercise in that you learn
more about what the code looks like when it comes out of the compiler,
and you get a better idea of what is going on inside the machine.

### Get familiar with the processor
The X86-64 processor is default processor for this exercise, although
there are virtual machines available for ARM64 and RISCV-64. You should
know a little about each processor before you attack programs on it.

What follows below is not an exhaustive description of a processor,
but probably the minimum you need to know to start understanding
a disassembled program.

#### X86-64 Registers
First, for the X86-64, get familiar with the registers and the ABI
(Application Binary Interface). You don't need to be able to recite
the names of all the registers from memory, but it is helpful to know
the forms of the names. The X86-64 is descended from the 8086 processor,
which was a 16-bit processor that itself was a descendant of the 8008
and 8080 processors. What this means is that as the processor has grown,
it has added larger registers on top of existing smaller ones. So,
the 64-bit RAX register contains in its rightmost 32 bits the 32-bit
EAX register, which contains in its rightmost 16 bits the 16-bit AX
register, which in turn is made of up the AH and AL (A-High and A-Low)
registers. So, when you see R in the register name followed by any
letters, you know it is the 64-bit register. If you see E, it is 32-bit,
and in general the rest are 16-bit, except for the ones that end in H or
L which means they are the upper or lower 8 bits of a 16-bit register.
Since the X86-64 has added a number of registers that didn't exist in
the smaller versions, you will see registers numbered R8-R15. With
no additional letters after them, these are the 64-bit registers (i.e.
when you see R8, that's a 64-bit register). If the register is R, a
number, and then D, that's a 32-bit register (R8D is the rightmost 32
bits of R8), and a W indicates it is a 16-bit register (R8W is the
rightmost 16 bits of R8), and finally a B indicates an 8-bit register,
so R8B is the rightmost 8 bits of R8.

The RSP register is the stack pointer, it points to the top of the
stack, which grows downward. That is, if the stack pointer points
to address 0x8000 and you push 4 bytes onto the stack, the stack pointer
will now be 0x7FFC. The RBP is a companion to the stack pointer, it
usually points to the base or bottom of a stack frame. Whenever you
call a function, the return address of the function is pushed onto
the stack, and then if the function has any local variables, it needs
to add more space to the stack for the local variables. Typically
the code at the beginning of a function will save the current RBP
register on the stack, and then set RBP to the current RSP, so that
RBP points to the current top of the stack, then it decrements the
stack pointer by the amount of local storage it needs. It then uses
RBP as the base address to refer to variables. You notice many places
in a function where it might do something like:
```
   mov   -0x20(%rbp),%eax
```
When you see the pattern nnnn(%rbp) that's usually a reference to
a local variable that is stored on the stack, and in the above case,
since it is moving it to %eax, the 32-bit version of RAX, it is
a 32-bit number stored beginning 0x20 (32 decimal) bytes before the
bottom of the stack frame.

When a function returns, it typically copies the RBP register back into
the stack pointer, restores the old RBP register that was pushed onto
the stack, and then pops the return address from the stack and jumps
to the address. This is often performed by the LEAVEQ instruction.

When a function is called, the CALLQ instruction pushes the instruction
pointer onto the stack, which by the time CALLQ executes is already
pointing to the next instruction after CALLQ. A function might have
an ENTERQ instruction, or it might manually push RBP onto the stack
and then set RBP to the current RSP.

The RIP register is the instruction pointer, it tells what memory
location is going to be executed next. Whenever an instruction is
executed, RIP already points to the instruction that comes after it.

Other registers are used for computation or for passing parameters (or
both). Since these targets are being attacked in a Linux system, you
should know that the Application Binary Interface (ABI) for X86-64
on Linux specifies that the registers used to pass the first 6
arguments to a function are, in order: %rdi, %rsi, %rdx, %rcx,
%r8, and %r9. This means that when you see a CALLQ instruction that
calls a function, you should look immediately before it to see
where the parameters come from. Whatever is loaded into the %rdi
register is the first parameter to the function, whatever is in %rsi
is the second, etc.

#### Some common X86-64 instructions
The most common instruction in the X86-64 is the mov (move) instruction.
It has so many variations that someone was able to prove that the
mov instruction alone is Turing-complete - that is, you can do
everything a Turing machine can do while only using the mov instruction,
and thus you can theoretically compute anything that is computable.
But, you'll typically find that it is just used to move data from
point A to point B, where at least one of those two is a register,
sometimes both.

The notation can vary for disassembly, as it does for assembly. One
thing to keep in mind is that there is an Intel style and an AT&T style
and the parameters to mov are in a different order for each. In the
Intel style, the destination comes first, then the source, so in
the Intel style, the following instruction copies the contents of
EBX to EAX (think of mov in this style like an assignment eax := ebx):
```
   mov eax, ebx
```

The AT&T style, which is the default for GDB and what you will see
when running this debugger, has the source first and then the
destination, so to copy ebx into eax, we do this (notice the % in front
of the register names in AT&T style):
```
   mov %ebx, %eax
```

You may see different variations of a jump instruction, like jmp,
which unconditionally jumps (i.e. does a GOTO) to another location,
or you may see j followed by some condition like e for equal, le
for less-than-or-equal, ne for not equal, so je, jle, jne, etc.
The instruction doesn't contain any comparisons. Instead, it looks
at some CPU flags that are set by the results of other instructions.
For instance, the cmp instruction compares two values. On
many processors, if you do arithmetic that results in a zero it sets
a zero flag. The test instruction does a bitwise and between the
two arguments, and is often used to test a variable to see if it is
zero, like:
```
   test %eax, %eax
```
If EAX is not zero, then there is at least one bit that is set, and
anding EAX with itself will keep those bits set, so the zero flag will
not be set. On the other hand, if EAX is zero, the zero flag is set,
so you'll often see a test with the same two arguments followed by
either a je or jne instruction.

You'll see some arithmetic instructions like add (sometimes with letters
after the instruction to indicate the size of the arguments, xor
in at least one of the targets. Also, push will push a value onto the
stack and pop will pop one off.

One other instruction that occurs occasionally is lea, which is
"load effective address". It means to put the address of the first
argument into the second one. For example:
```
   lea   -0x20(%rbp), %rax
```
The above lea instruction refers to a value that is hex 20 bytes less
than the value of %rbp. In this case, it is the equivalent of 
these two instructions, which would transfer %rbp to %rax and then
subtract 0x20 from %rax:
```
   mov  %rbp, %rax
   sub  $0x20, %rax
```

#### Addressing modes
The X86-64 has a variety of addressing modes, which refers to how
to specify the arguments to an instruction. For example, you might
use the name of a register, which tells it to use the contents of
that register. You might have a number with a $ in front of it, which
means to use that actual value. In `sub  $0x20, %rax` instruction,
the $0x20 is called an immediate value - it means the number should
be interpreted as the number itself and not as an address. On
the other hand, a number without a $ usually indicates an address.
An exception to this is when you see register-indexed addressing like
this:
```
   movb  $0x21, 0x2ec7(%rip)
```
Now, the above example actually contains two kinds of addressing.
The first, the $0x21, is an immediate value, it means you are moving
the constant 0x21 somewhere. The second argument is an offset and
a register in parentheses. This means to take the value in that
register, and add the offset to it, and that is the address that
in this case is the destination where to move 0x21 to. For example,
let's suppose that %rip had the hex value 0x2000. The processor would add 0x2ec7
to that 0x2000 to get the address 0x4ec7, and would then store the byte
value (movb = move byte) at memory location 0x4ec7.

Hopefully this is enough information to get you going. The target
programs don't generally do anything esoteric except in a few cases.
I wouldn't recommend trying to comprehend the AES256 encryption
function in Target 3, for example.

#### Kinds of Attacks
Maybe you feel like you now have a tenuous grasp on what the
instructions do and you have started looking at the first target.
Sometimes you just need to figure out what the program is doing and
where it is getting its data from. In these exercises, the disassembler
is able to give you symbol names a lot of the time, and that
can be a big help. For example, there is one symbol named
check_password, which if you are trying to figure out what the password
is, that's probably a good place to start looking. Maybe then you look
to see where it might be comparing things. You might then use the
debugger to see what it is comparing. This kind of attack is just
looking for the behavior of the program and not trying to manipulate
it at all.

Another kind of attack sometimes requires luck, which is that of a
buffer overflow. There are times when a program reads data into an
array and does not stop reading into the array when it gets to the
end of the array, so the values read in overwrite whatever is in memory
after the array. A notorious function for this is named `gets` and
it reads from stdin into an array but is not given a maximum number of
characters to read, so it is very easy for an attacker to just keep 
entering data and corrupt the memory of the program.

Spoiler: These target programs use gets, although you don't need
to worry about that until Target 4.

To get an idea for how to attack with a buffer overflow, use the 
memory window to see what the stack looks like. Maybe set a breakpoint
after the gets, or after the prompt function in the target programs,
enter some data at the prompt, and then when it hits the breakpoint,
go to the memory window and hit 's' which will show you the stack
part of the memory. You can use the register window to see the %rsp
and %rbp registers to determine the bounds of the current stack frame
and then look in that part of memory and see if you can see the
characters you entered. Remember earlier in the description of the
stack and function calls that there are local variables stored on
the stack, so sometimes typing extra values to overflow a buffer can
let you set the value of some other variable that you want to change.
Or, since return addresses are stored on the stack, maybe you can enter
data in just the right way so that it returns to a different part
of the program (the convenient "hex input" option on the
password screen can assist here). Or maybe you need to change the
behavior of the program by getting it to execute some custom code
that you write. Maybe you can overflow the buffer in a way that
inserts some code into memory and then manipulates the return
address to jump to that code.

While there aren't any examples of it here, another form of attack is
to overflow an integer. For example, if you have to enter the number
of bytes you are going to send, and then you send those bytes, you
might exploit code that doesn't handle signed numbers correctly.
For example, imagine you have this C code:
```c
   int len;
   char buffer[2000];

   len = read_len();
   if (len > 2000) {
      len = 2000;
   }
   read_bytes(buffer, len);
```

Furthermore, suppose that read\_bytes is declared as:
```
unsigned int read_bytes(char *, unsigned int);
```

The problem here is that len is signed, but read\_bytes takes an
unsigned value. What if you entered a value like 4000000000 in
read\_len, this would be returned as a negative number because
4000000000 is greater than the largest positive 32-bit number,
but the code that checks len doesn't take into account that it is
negative, and since read_bytes takes an unsigned number, it will
silently pass 4000000000 to read\_bytes which will really overflow
the 2000-byte buffer that was declared. A signed value that is negative
when passed as an unsigned value becomes a positive number that is
larger than the largest possible positive signed value. Again, this
doesn't occur in any of the targets here, but this might be something
to remember in the future, especially for defensive coding.
