# Capture-the-Flag - Disassembly & Exploitation

This code is my final project for Vanderbilt CS 6387 Topics in Software Engineering - Security.
It was inspired by the Capture-the-Flag trainer at https://microcorruption.com, but I wanted mine
to use 64-bit processors instead of the TI MSP430 used by the Microcorruption site.
The basic premise is the same - you are given a program that prompts you for a password and
interacts with an electronic lock. Your goal is to unlock the lock.

There are 6 targets to try ranging in difficulty. The features of the 6 targets are:

## 1 - Ready-to-Go
The Target 1 lock is a system where you just connect up the lock and it is ready to go. You don't even
have to set an initial password since the system comes pre-configured with one.

## 2 - Even More Ready, No Trickery!
Target 2 is an improvement over Target 1. You may have heard rumors of people finding the Target 1 password
somewhere in the code for the lock, but you don't need to worry about that with target 2, because the
password is hidden mathematically.

## 3 - AES256 Strong
Target 3 uses state-of-the-art AES 256-bit security to protect its passwordÂ¸so no simple math tricks will
break this encryption!

## 4 - The Password Lockbox
What's better than using AES 256-bit security to protect the password? Not even keeping the password on the
system in the first place! Target 4 features a redesigned lock in which the lock is securely stored in the
lock itself and not in the computer controlling it. You can no longer get to the password through the
computer, and the lock now makes the determination whether or not the password is correct.

## 5 - The Simple-is-better Password Lockbox
We discovered a potential flaw in Target 4 where a variable might be tampered with to trick the system into
opening the lock. We simplified our algorithm so this is no longer possible and the lock is even more secure.

## 6 - Safer, Less Jumpy
Some locks might be vulnerable to jumping around in the code and causing the lock to unlock, but not this one.
A special interlocking mechanism prevents someone from causing the password program to jump to the wrong location.

(Note: If you are trying Target 6 on the ARM64 processor, you may find that it is hard to attack because of the
simplicity of the program, the way it interacts with the server, and the way ARM64 stores return addresses.
The Target6-Arm target adds an extra layer of function calls to facilitate exploits)


# Building and Running
There are two components to the system - the targets and the server/debugger. To build the target programs and the server/debugger, you need the GCC compiler, make, a recent version of Go, and GDB. On a Debian system, you
should be able to get these with:
```shell
sudo apt install build-essential gdb golang-go
```

### Building the targets
In the target\_programs directory is a Makefile, you should just be able to do:
```shell
make
```

### Building the server
The server is written in Go, so you need a recent version of Go installed, one that supports the module system. I used 1.16.
You can build the server with this command from the server directory:
```shell
go build -o server main/main.go

### Running the server
You'll need GDB installed. On a Debian-based system (including Ubuntu and Linux Mint) you can do:
```shell
sudo apt install gdb
```

Then, just run the server:
```shell
./server
```

You should see a screen like this:
![Debugger screen](img/server1.png)

## Running Targets
To run a target, just click on the target name at the top of the screen. If you click on Target1, it should
look something like this:
![Debugger screen running target](img/server2.png)

### Navigation Commands
To scroll through the memory and disassembly windows.

#### Disassembly Window
You can use the following keys to navigate the disassembly window:

|Keystroke    |Result                            |
|-------------|----------------------------------|
|Control-B    |Scroll back 10 lines              |
|Control-F    |Scroll forward 10 lines           |
|Up or k      |Scroll back 1 line                |
|Down or j    |Scroll forward 1 line             |
|b            |Toggle breakpoint on current line |
|i            |Jump to current instruction       |


#### Memory Window
You can use the following keys to navigate the memory window:
|Keystroke    |Result                                      |
|-------------|--------------------------------------------|
|Control-B    |Scroll back 10 lines                        |
|Control-F    |Scroll forward 10 lines                     |
|Up or k      |Scroll back 1 line                          |
|Down or j    |Scroll forward 1 line                       |
|p            |Jump to beginning of program memory         |
|d            |Jump to beginning of program data           |
|s, S, or G   |Jump to beginning of stack memory           |
|m, M or g    |Jump to lowest memory location              |

#### Command Window
In the command window on the right-hand side, you can enter additional
commands:

|Command            |Result                                         |
|-------------------|-----------------------------------------------|
| b addr            |Set a breakpoint at the given address or symbol|
| b symbol          |Set a breakpoint at the given address or symbol|
| break addr        |Set a breakpoint at the given address or symbol|
| break symbo       |Set a breakpoint at the given address or symbol|
| cb addr           |Clear a breakpoint at the given address        |
| clear addr        |Clear a breakpoint at the given address        |
| ca                |Clear all breakpoints                          |
| clearall          |Clear all breakpoints                          |
| s or step         |Step into the next instruction, if it is a function, step into the function |
| n or next         |Step over the next instruction, if it is a function, step over the function |
| c or cont         |Continue executing until a breakpoint or termination |
| v function        |Scroll to the named function in the disassembly window |
| view function     |Scroll to the named function in the disassembly window |
| vm addr           |Scroll to the given address in the memory window |
| viewmem addr      |Scroll to the given address in the memory window |
| solve             |Run the program outside of debugging to be sure you can open the lock without the debugger|
| reset             |Reset the program to the beginning and clear breakpoints |


## Solution Videos
I have made some Youtube videos walking through each of these solutions, as well as one for Target 8,
for which I don't have a solution, but instead an explanation of why I don't have a solution for it.
You can view them [here](https://www.youtube.com/playlist?list=PLOc_FZ5lfpGt6su7Xxu5zE9O94BQpX77U).

## Other Platforms
Most users will probably run these targets on an X86-64 machine, and the Youtube videos showing how
to solve them are based on the X86-64. However, the server knows how to do ARM64 and Riscv-64 processors
as well. You will need the Qemu system emulator installed on a Linux system in order to run these virtual machines.
Each virtual machine is roughly 1.5GB in size before downloading and 3-4GB when unzipped.

There are virtual machines available for the following processor architectures:
[ARM64](http://www.wutka.com/download/exploits_aarch64.zip)
[RISCV-64](http://www.wutka.com/download/exploits_riscv64.zip)

When Qemu is emulating a processor that is different from the underlying hardware, it tends to be much slowing
than running on the actual hardware. You should expect the system to be fairly sluggish - like when you click
on a particular target, it may be 10-20 seconds before the program actually appears.

### ARM64
Once you download a the ARM64 zip file:
```shell
unzip exploits_aarch64.zip
cd exploits_aarch64
./run-aarch64
```
The run-aarch64 command will start Qemu, but you probably want to SSH into it from a separate terminal window
in order to run the simulator. Open another window, resize it to be fairly wide and tall and do:
```shell
ssh -p 2222 debian@localhost
cd exploits_aarch64/server
./server
```

Remember that you may not be able to adequately exploit a buffer overflow on Target 6 and may need
to use Target6-Arm on the ARM64 processor.

### RISCV-64
Once you download a the ARM64 zip file:
```shell
unzip exploits_riscv64.zip
cd exploits_riscv64
./run-riscv64
```
The run-riscv64 command will start Qemu, but you probably want to SSH into it from a separate terminal window
in order to run the simulator. Open another window, resize it to be fairly wide and tall and do:
```shell
ssh -p 2222 debian@localhost
cd exploits_riscv64/server
./server
```
