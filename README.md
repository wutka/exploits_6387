# Capture-the-Flag - Disassembly & Exploitation

This code is my final project for Vanderbilt CS 6387 Topics in Software Engineering - Security.
It was inspired by the Capture-the-Flag trainer at https://microcorruption.com, but I wanted mine
to use 64-bit processors instead of the TI MSP430 used by the Microcorruption site.
The basic premise is the same - you are given a program that prompts you for a password and
interacts with an electronic lock. Your goal is to unlock the lock.

There are 6 targets to try ranging in difficulty. The features of the 6 targets are:

## 1 - Ready-to-Go
The Target 1 lock is a system where you just connect up the lock and it is ready to go. You don't even
have to set an initial password since the system comes pre-configured with one.

## 2 - Even More Ready, No Trickery!
Target 2 is an improvement over Target 1. You may have heard rumors of people finding the Target 1 password
somewhere in the code for the lock, but you don't need to worry about that with target 2, because the
password is hidden mathematically.

## 3 - AES256 Strong
Target 3 uses state-of-the-art AES 256-bit security to protect its passwordÂ¸so no simple math tricks will
break this encryption!

## 4 - The Password Lockbox
What's better than using AES 256-bit security to protect the password? Not even keeping the password on the
system in the first place! Target 4 features a redesigned lock in which the lock is securely stored in the
lock itself and not in the computer controlling it. You can no longer get to the password through the
computer, and the lock now makes the determination whether or not the password is correct.

## 5 - The Simple-is-better Password Lockbox
We discovered a potential flaw in Target 4 where a variable might be tampered with to trick the system into
opening the lock. We simplified our algorithm so this is no longer possible and the lock is even more secure.

## 6 - Safer, Less Jumpy
Some locks might be vulnerable to jumping around in the code and causing the lock to unlock, but not this one.
A special interlocking mechanism prevents someone from causing the password program to jump to the wrong location.


# Building and Running
There are two components to the system - the targets and the server/debugger.

### Building the targets
In the target_programs directory is a Makefile, you should just be able to do:
```shell
make
```

### Building the server
The server is written in Go, so you need a recent version of Go installed, one that supports the module system. I used 1.16.
You can build the server with this command from the server directory:
```shell
go build -o server main/main.go

### Running the server
You'll need GDB installed. On a Debian-based system (including Ubuntu and Linux Mint) you can do:
```shell
sudo apt install gdb
```

Then, just run the server:
```shell
./server
```

You should see a screen like this:
![Server screenshot](img/server1.png)

## Running Targets
To run a target, just click on the target name at the top of the screen. If you click on Target1, it should
look something like this:
![Target1 screenshot](img/server2.png)

### Navigation Commands
To scroll through the memory and disassembly windows.

#### Disassembly Window
You can use the following keys to navigate the disassembly window:

|Keystroke    |Result                            |
|-------------|----------------------------------|
|Control-B    |Scroll back 10 lines              |
|Control-F    |Scroll forward 10 lines           |
|Up or k      |Scroll back 1 line                |
|Down or j    |Scroll forward 1 line             |
|b            |Toggle breakpoint on current line |
|i            |Jump to current instruction       |


#### Memory Window
You can use the following keys to navigate the memory window:
|Keystroke    |Result                                      |
|-------------|--------------------------------------------|
|Control-B    |Scroll back 10 lines                        |
|Control-F    |Scroll forward 10 lines                     |
|Up or k      |Scroll back 1 line                          |
|Down or j    |Scroll forward 1 line                       |
|p            |Jump to beginning of program memory         |
|d            |Jump to beginning of program data           |
|s, S, or G   |Jump to beginning of stack memory           |
|m, M or g    |Jump to lowest memory location              |

#### Command Window
In the command window on the right-hand side, you can enter additional
commands:

|Command            |Result                                         |
|-------------------|-----------------------------------------------|
| b addr            |Set a breakpoint at the given address or symbol|
| b symbol          |Set a breakpoint at the given address or symbol|
| break addr        |Set a breakpoint at the given address or symbol|
| break symbo       |Set a breakpoint at the given address or symbol|
| cb addr           |Clear a breakpoint at the given address        |
| clear addr        |Clear a breakpoint at the given address        |
| ca                |Clear all breakpoints                          |
| clearall          |Clear all breakpoints                          |
| s or step         |Step into the next instruction, if it is a function, step into the function |
| n or next         |Step over the next instruction, if it is a function, step over the function |
| c or cont         |Continue executing until a breakpoint or termination |
| v function        |Scroll to the named function in the disassembly window |
| view function     |Scroll to the named function in the disassembly window |
| vm addr           |Scroll to the given address in the memory window |
| viewmem addr      |Scroll to the given address in the memory window |
| solve             |Run the program outside of debugging to be sure you can open the lock without the debugger|
| reset             |Reset the program to the beginning and clear breakpoints |

## Other Platforms
Most users will probably run these targets on an X86-64 machine, and the Youtube videos showing how
to solve them are based on the X86-64. However, the server knows how to do ARM64 and Riscv-64 processors
as well. You will soon find links here to Qemu virtual machines you can use to try these processors
even if you don't have access to a physical one.
